<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
   <TITLE>Literate Programming</TITLE>
<META NAME="description" CONTENT="A brief history of the literate programming paradigm, recent work,
links and books, and some ideas that we're working on, with apologies to the established players.">
<meta name="keywords" content="literate,programming,knuth,cweb,norman,ramsey,TeX,noweb,funnelweb,fweb">
</head>

<body bgcolor="#FFFFFF" link="#000099" vlink="#990000" alink="990000">
<table width="100%">
<tr>
<td valign="top" width="150px"><div class="sidebar">
<div class="border">
<div class="sidemenu">
<p class="smtitle">vivtek</p>
<p>[ <a href=/>home</a> ]</p>
<p>[ <a href=/blog/>blog</a> ]</p>
<p>[ <a href=/wiki_index.html>recent</a> ]</p>
<p>[ <a href=/fiction/>fiction</a> ]</p>
<p>[ <a href=/toonbots/>toonbots</a> ]</p>
<p>[ <a href=/toon-o-matic/>toon-o-matic</a> ]</p>
<p>[ <a href=/wftk/>workflow</a> ]</p>
<p>[ <a href=/projects/>programming</a> ]</p>
<p>[ <a href=/services.html>translation</a> ]</p>
<p>[ <a href=http://semantic-programming.blogspot.com/>semprog&nbsp;blog</a> ]</p>
<p>[ <a href=http://big-old-house.blogspot.com/>house</a> ]</p>
<p>[ <a href=http://xlat-perl.blogspot.com/>xlat&nbsp;project</a> ]</p>
<p>[ <a href=/contact.html>contact</a> ]</p>
</div>

<hr />
<script type="text/javascript"><!--
google_ad_client = "pub-7508846022405297";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_ad_type = "text";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<a href="/blog/t/ah_google_adsense_we_hardly_knew_ye!.html">Where
did my Google go?</a>

</div>

</div>
</td>
<td valign="top"><div class="content">


<center><table><tr><td>
<h2>Topic: <u>Literate programming</u></h2>
[&nbsp;<a href=#more>additional&nbsp;information</a>&nbsp;] [&nbsp;<a href=#links>links</a>&nbsp;] [&nbsp;<a href=#books>books</a>&nbsp;]
[&nbsp;<a href=/lpml.html>project</a>&nbsp;]
</td></tr>

<tr><td><table width=75%><tr><td><font face=arial>
Synopsis:<br>A brief <a href=#historical>history</a> of the literate programming paradigm, 
<a href=#recent>recent work</a>, and <a href=#analysis>some ideas
that we're working on</a>, with apologies to the established players.
</font></td></tr></table></td></tr>

<tr><td>
<a name=historical>
<strong><font size=+1>Historical sketch</font></strong><br>
The term <i>literate programming</i>, and the original literate programming system (<code>WEB</code>) which implemented
the concept, were both the creation of Donald Knuth, one of the most literate programmers the world has ever known.  Knuth,
of course, is the author of <u>The Art of Computer Programming</u>, the TeX typesetting system, and other works of the
programming art.  It was Knuth's intention to provide a system of programming by which the programmer could typeset his or her
work in book or article form, so that each choice of implementation, each algorithm, was clearly explained and justified.  The
resulting work of art would then stand as the quintessential definition of a solution for the problem it addressed.
<p>
Knuth used and developed this system while writing TeX and Metafont, and the resulting two books of code/documentation remain
the most readable and usable collections of code I have ever seen.  TeX, of course, is the standard of typesetting software
in the academic world (usually in its LaTeX incarnation, which runs as a macro package on basic TeX), and has been for nearly twenty
years.  Twenty years for a software package!  Only Unix has comparable staying power.
<p>
Literate programming, however, is not a mainstream technique.  Those who use literate programming
tools often wonder why not.  There have been no studies done of which I am aware, but the basic shortcoming
of literate programming is that it is difficult to write a literate program quickly.  Yes, once it is written, it is impeccably
documented, easily debugged (in those cases where it isn't already provably correct), simply maintained by the original author
and others, and in general simply has a far higher quality in every respect than an "illiterate" program.  <strong>But</strong>
it takes longer to see results.  As <a href=/linkout/www.unitedmedia.com/comics/dilbert/>we all know</a>, the software
industry is an impatient one.  And corporate IT in industries other than our beloved software are even less patient and less
likely to understand the benefits of good coding style.
<p>
[update 4/20/2000] Having completed the first phase of a large project in literate style (<a href=/wftk/todomgr/index.html>the
task list manager for wftk</a>, around 1200 lines of Tcl code) I can say that I seem to be coding somewhat more slowly in
literate style, but that being able to find relevant parts of a rather large program appears to make up the difference.
<p>
<a name=recent>
<strong><font size=+1>Recent work</font></strong><br>
Since Knuth, literate programming has seen a few innovations.  There are a number of literate
programming systems available, and probably the most active is Norman Ramsey's <code>noweb</code>,
which you may explore at <a href=/linkout/www.cs.virginia.edu/~nr/noweb/>Ramsey's own page</a>.
He also maintains links to many of the projects which use his system, so you can see a number of examples
of literate programming in action.
<p>
I have yet to study <code>noweb</code>.  Its chief innovations seem to be to keep up with programming
technology.  It is (relatively) language-independent, it is extensible, and it can work with programs
which consist of more than one code file (unlike Knuth's original Pascal tool, which assumes a single
code output!)  Watch this space for further details, or go get <code>noweb</code> and try it out yourself.
<p>
<code>&lt;shameless plug&gt;</code><br>
I'm also both developing and using <a href=/lpml.html>my own literate programming tool</a>,
as any literate programmer must.  Go check it out.  Use it, even, you'd make my day.<br>
<code>&lt;/shameless plug&gt;</code>
<p>
<a name=analysis>
<strong><font size=+1>Analysis</font></strong><br>
When writing a literate program using existing technology, the programmer is simultaneously writing
the program code and writing the typesetting code which will be used to typeset the final documentation.
Since Knuth created TeX, most of these systems use TeX as their typesetting language.  Some use
other typesetting languages.  The resulting documentation consists of paragraphs of actual English
text (possibly containing illustrations or mathematical formulae) interspersed with program text.
The program text is broken into small, understandable chunks.  Each chunk may include other chunks by
means of a marker which identifies the code to be included.  The included code is inserted only into
the compiler-ready code output; it does not appear explicitly in the program documentation, where
it would only obscure the structure of the chunk being explained.
<p>
The process of creating the typeset documentation is called <i>weaving</i>; the process of creating
the program code for compilation is called <i>tangling.</i>  The reason for this is that Knuth particularly
disliked compilers for constraining the order of presentation of program parts.  He stresses an
easily understandable order of presentation as something crucial for the program author's explanation
of program logic.
<p>
The final program documentation may also contain various lists of identifiers used in the program,
where code segments are used and where they are defined, and so forth.  This provides an excellent
means of understanding the program.  For a good introduction, find one of Knuth's published programs
and read it.  You will immediately see that this is a good way of documenting program development.
<p>
In my view, there are three crucial functional aspects of literate programming:
<ul>
<li>Template processing allows code segments to be broken into understandable chunks and reassembled
prior to compilation.
<li>Since only one source is used for both code and documentation, the program is always
guaranteed to be in synch with its documentation.  Seeing a clear exposition of the program
code may also induce the maintenance programmer to correct it when a mistake is found, instead of
merely correcting the program code and leaving the specification in its original erroneous state.
<li>Automatic program analysis allows the printed documentation to include information about
identifiers and other program constructs with no human intervention.  If well-designed, these
indices can provide an incredible boost to the quality of the documentation.
</ul>
<p>
With these fundamental requirements in mind, we are trying to generalize these points in preparation
for development of our two chief vaporware offerings.  (See <a href=/vaporware.html#litprog>this description</a>.)
In general, we want to take literate programming and make of it a system that we will actually
use in the context of paid programming work.
  (<a href=/linkout/www.interlog.com/~gray/snoweb.html>Here's a good take on that point of view that's good for a laugh or two.</a>)

For that to be possible, the effort required to
produce a literate program must be of the same order of magnitude as the effort required simply to
code up a product and to debug it.  This means that it must be simple to take existing test
code and reverse-engineer it to produce an explanation of its workings in literate style.  The editor
used to create the program must be easy to use and must understand literate style.  The code must
be accessible in its tangled form and changes to it in tangled form must propagate back into the
literate source.
<p>
For each of the three points above, we have identified the processes that we envision.  The finished
literate product will be a far cry from current literate programming technology, and we think that
this will have the potential to bring literate programming into the mainstream, simply via evolutionary
forces if in no other way.  Literate programming should <i>increase</i> an individual's productivity
if applied correctly.
<p>
Here's how we see the eventual programming environment:
<p>
<i>Product description language</i><br>
This generalizes the first of LP's three components.  In addition to allowing code segments to be
inserted into other segments, defining the files to be created, and doing simple macro processing,
it should be possible to generate code on the basis of database queries, for example, or perform
other generalized data manipulation to define a program.  For instance, if a parser is a component
of the program, then the yacc and lex code for the parser should be the source used to generate
the program.  During tangle, yacc and lex are called to produce C code, and that resulting code
segment is then inserted into the final program.  It isn't necessary ever to see that code, but
it should be acknowledged and documented that it exists.  I'm sure you can think of a few
applications of this, too.
<p>
<i>Annotation</i><br>
Code segments are associated rigidly with text in current LP technology.  However, we would like
the ability to annotate any action taken.  If a change is made to existing code, that change 
should be tracked, annotated, and incorporated into the final documentation, so that the thoughts
of each maintenance programmer can be followed in making later changes.  This whole idea is still
somewhat vague; as usual, please watch this space for further details.
<p>
<i>Code analysis</i><br>
Ideally, each language used in a program would be understood and parsed during editing.  The results
of this parsing would be available for code analysis procedures.  This corresponds to current LP
technology's inclusion of information about identifiers into the final documentation; I think that
this information is crucial during composition and maintenance of the code.  And I'm starting to
take a more active interest in the whole arena of analysis and measurement -- check out my <a href="/code_analysis.html">topic
on code analysis and software measurement</a> for some of the thoughts I'm turning over.  If a general
code analysis framework were combined with a literate programming documentation facility, then, well,
words fail me.  It would be a Good Thing.
</td></tr>


<tr><td>
<a name=more>
<center><font face=arial size=+1>ADDITIONAL INFORMATION</font></center></td></tr>

<tr><td>
<ul>
<li><strong><a href=/lpml.html>lpml</a></strong><br>
LPML (Literate Programming Markup Language) is Vivtek's first stab at XML Literate programming.
It's free.  And the source is, of course, programmed
literately (it tangles and weaves itself).  <a href=/lpml/lpml_alpha/index.html>Here's the programming documentation for
the prototype Perl script.</a>  Take a look and tell me what you think.
<li><strong><a href=/wftk/todomgr/index.html>wftk task list manager code</a></strong><br>
The task list manager component of the wftk is done (<i>4/20/2000</i>).  This is an example of what 1200 lines of code
can look like when documented in literate style.  Personally I find things much easier to find when I need to make a change.
</ul>
</td></tr>

<tr><td>
<a name=links>
<center><font face=arial size=+1>LINKS</font></center></td></tr>

<tr><td>
<ul>
<li><strong><a href=/linkout/www.literateprogramming.com>www.literateprogramming.com</a></strong> (Added 2/12/99)<br>
New movement on the LP front!  This site has an excellent download selection of articles, examples, and Windows/NT
versions of software, and (get this) it's newer than 1994.  Definitely worth a visit.
<li><strong><a href=/linkout/shelob.ce.ttu.edu/daves/lpfaq/faq.html>The Literate Programming FAQ</a></strong><br>
The FAQ contains, of course, the basic information about literate programming, a list of available tools, and so
forth.  It is extremely current (Mar 2000 as this was written.)
<li><strong><a href=/linkout/www.cs.virginia.edu/~nr/noweb/>Norman Ramsey's <code>noweb</code> page</a></strong><br>
These pages have links to a number of LP resources.  You can also get <code>noweb</code> here.
<li><strong><a href=/linkout/www.desy.de/user/projects/LitProg/>Marcus Speh's pages at DESY</a></strong><br>
These pages contain a great deal of information about literate programming, but it would seem as though
they haven't been maintained for a few years.  Most of the information dates to about 1993-1995 and many of 
the outgoing links point to pages that no longer exist.  But it's definitely worth reading through, don't
get me wrong!  The links that do still work are full of good information.
<li><strong>The Literate Programming Webring</strong><br>
The LP ring consists of 10 sites as of May 1999, and they're probably a good indication of where
the activity remains in the LP world.  <a href="http://www.webring.org/cgi-bin/webring?ring=litprog;list">List the whole
lot</a> or <a href="http://www.webring.org/cgi-bin/webring?ring=litprog;random">just visit one at random</a>.  (Or visit the
<a href="http://www.webring.org/cgi-bin/webring?ring=litprog;id=10;next">next site</a> or the
<a href="http://www.webring.org/cgi-bin/webring?ring=litprog;id=10;prev">previous site</a> in the
ring.)
</ul>
</td></tr>

<tr><td>
<a name=books>
<center><font face=arial size=+1>BOOKS</font></center></td></tr>

<tr><td>
<ul>
<li><table border=0><tr valign=top><td><A HREF="http://barnesandnoble.bfast.com/booklink/click?sourceid=294764&ISBN=0201134373"><IMG SRC="http://barnesandnoble.bfast.com/booklink/serve?sourceid=294764&ISBN=0201134373" BORDER="0" WIDTH="1" HEIGHT="1" ><img border=0 src=http://shop.barnesandnoble.com/BookSearch/bookCover.asp?ean=9780201134377></a></td>
<td><u><strong>TeX</strong>: the program</u><br>
<i>Donald E. Knuth, Addison-Wesley Longman, 1986.  ISBN 0-201-13437-3</i><br>
Read this book.  You will see why literate programming would work for you.  Really.  If everyone
wrote software like this, we'd be fifty years ahead of ourselves.
<center><A HREF="http://barnesandnoble.bfast.com/booklink/click?sourceid=294764&ISBN=0201134373"><IMG SRC="http://barnesandnoble.bfast.com/booklink/serve?sourceid=294764&ISBN=0201134373" BORDER="0" WIDTH="1" HEIGHT="1" >Check it out at<br><img alt="Barnes and Noble" border=0 src=/images/barnesandnoble2.gif valign=middle></A></center>
</td></tr></table>
<li><table border=0><tr valign=top><td><A HREF="http://barnesandnoble.bfast.com/booklink/click?sourceid=294764&ISBN=0201575698"><img border=0 src=http://shop.barnesandnoble.com/BookSearch/bookCover.asp?ean=9780201575699></a></td>
<td><u><strong>The CWEB System of Structured Documentation</strong></u><br>
<i>Donald E. Knuth and Silvio Levy, Addison-Wesley Longman, 1994.  ISBN 0-201-57569-8</i><br>
This book is the user manual for Knuth and Levy's C version of the original <code>WEB</code> system.
It's a fairly good example of literate programming, but I don't think it adds much to the other books
listed here, except for an interesting method of parsing C and the fact that it's a shorter
example than TeX of a "real" software project.
<center><A HREF="http://barnesandnoble.bfast.com/booklink/click?sourceid=294764&ISBN=0201575698"><IMG SRC="http://barnesandnoble.bfast.com/booklink/serve?sourceid=294764&ISBN=0201575698" BORDER="0" WIDTH="1" HEIGHT="1" >Check it out at<br><img alt="Barnes and Noble" border=0 src=/images/barnesandnoble2.gif valign=middle></A></center>
</td></tr></table>
<li><table border=0><tr valign=top><td>NO<BR>PICTURE</td>
<td><u><strong>Literate Programming</strong></u><br>
<i>Donald E. Knuth, CSLI, 1992.  ISBN 0-9370-7380-6</i><br>
You'll find this book useful if you're wanting to think about the philosophy of programming and
why literate programming is a good thing to do.
<br><center>
<A HREF="http://barnesandnoble.bfast.com/booklink/click?sourceid=294764&ISBN=0937073806"><IMG SRC="http://barnesandnoble.bfast.com/booklink/serve?sourceid=294764&ISBN=0937073806" BORDER="0" WIDTH="1" HEIGHT="1" >Check it out at<br><img alt="Barnes and Noble" border=0 src=/images/barnesandnoble2.gif valign=middle></A></center>
</td></tr></table>

</ul>
</td></tr>
<tr><td>
<center>
 This <a href="http://www.webring.org/cgi-bin/webring">Literate Programming</a> site owned by Vivtek.
<br>
[ 
 <a href="http://www.webring.org/cgi-bin/webring?ring=litprog;id=10;prev5">Previous 5 Sites</a>
|
 <a href="http://www.webring.org/cgi-bin/webring?ring=litprog;id=10;sprev">Skip Previous</a>
|
 <a href="http://www.webring.org/cgi-bin/webring?ring=litprog;id=10;prev">Previous</a>
|
 <a href="http://www.webring.org/cgi-bin/webring?ring=litprog;id=10;next">Next</a>
|
 <a href="http://www.webring.org/cgi-bin/webring?ring=litprog;id=10;skip">Skip Next</a>
|
 <a href="http://www.webring.org/cgi-bin/webring?ring=litprog;id=10;next5">Next 5 Sites</a>
|
 <a href="http://www.webring.org/cgi-bin/webring?ring=litprog;random">Random Site</a>
|
 <a href="http://www.webring.org/cgi-bin/webring?ring=litprog;list">List Sites</a>
]
</center>


</table>


</div></td></td></table>

<br><br><br><br>
    <center><img src="/images/black.gif" height=1 width=300><br>
    <Font Size="-1"><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</Font>
</center>


</body>
</html>
