<litprog>
<object name="config.c" language="c" item="wftk_config"/>


<format name="index">
<html><head><title>wftk configuration module</title></head>
<body>
<h2>wftk: configuration module</h2>
<center>
[ <a href="wftk_engine.zip">download</a> ] [<a href="index.html">wftk core engine</a> ] [ <a href="wftk_adaptors.xml">xml source</a> ]
[ <a href="http://www.vivtek.com/wftk/discuss.pl">discussion</a> ]
</center>
<hr/>
<p/>
[##body##]

<center>
<hr width="75%"/>
<table width="75%"><tr><td><font size="-1">
This code and documentation are released under the terms of the GNU license.  They are
additionally copyright (c) 2000, Vivtek.  All rights reserved except those explicitly
granted under the terms of the GNU license.  This presentation was prepared with 
<a href="http://www.vivtek.com/lpml.html">LPML</a>.  Try literate programming.
You'll like it.
</font></td></tr></table>
</center>
</body></html>
</format>


<item name="wftk_config" label="wftk configuration module" format="index">
This is the configuration module for the wftk.  The configuration module is always
statically linked with the wftk engine and provides two things: a way to retrieve named
configuration values, and a way to retrieve named adaptors of a given class.
<p/>
Configuration is a little tricky, because some adaptors are statically linked with the engine,
while some are dynamically linked when needed.  Dynamic linking under Unix is something I don't
understand yet, so right now, dynamic linking is only working for Windows (where I do understand
it.)  Under Unix, then, you need to <i>modify</i> the configuration module in order to get it
to know about statically linked adaptors.
<p/>
Let's include all we need to include first off.

<piece>
#include [[stdarg.h>
#include [[stdio.h>
#include [[malloc.h>
#include [[string.h>
#include "xmlapi.h"
#include "wftk_internals.h"
#include "localdefs.h"
#ifdef WINDOWS
#include [[windows.h>  /* For dynamic loading declarations. */
#endif
</piece>

Note that the <code>windows.h</code> include is needed to deal with dynamic linking (HINST and such).
And speaking of dynamic linking, one of the things we need to do is to keep track of what we've already
loaded.  To do that, let's define some linked-list things.

<piece>
struct loaded_library {
   int adaptor_class;
   char adaptor[32]; /* Note the limit on adaptor name.  Since typical names are "localxml" or "oracle"
                        this limit should be quite sufficient. */
   char filename[256]; /* Here we'll build the path to the DLL. */
#ifdef WINDOWS
   HINSTANCE inst; /* This is how we'll do it under Win32.  Under Unix, I still have to learn how... */
#endif
   struct adaptor_info * ai;
   struct loaded_library * next;
};
struct loaded_library * loaded_libraries = NULL;
</piece>
Now, I'm tempted to put this into the session, so it can be cleaned up when the session unloads.  But
really I think it's session-independent.  This leaves me a little confused as to when it <i>should</i>
be cleaned up.  Oh, what a tangled web we weave.
<p/>
I think the best way to handle this is to create a cleanup function which can be called when the
wftk DLL is unloaded.  If the wftk is statically linked, then we can either call this explicitly, or
we can trust the OS to clean up properly for us when our process is terminated.  Does that make sense?
<p/>
Let's go ahead and define our cleanup:
<piece>
void config_cleanup ()
{
   struct loaded_library * ll;

   while (loaded_libraries) {
      ll = loaded_libraries;
      loaded_libraries = ll->next;
#ifdef WINDOWS
      FreeLibrary (ll->inst);
#endif
      free (ll);
   }
}
</piece>

On that note, let's look at the <code>config_get_adaptor</code> function.
Note a couple of things about this function.  First, if the adaptor descriptor is a null pointer,
that means that the config module should use the system default, and that default must be statically
linked at the moment.  (Later I'll work out how to signify a default DLL in the config structure.)
<p/>
To make the declarations of statically linked adaptors come out right, we need to declare a few functions
for each right here.  So to configure this config module with a new statically linked adaptor, all you
need to do is to declare the functions here, and then add the adaptor into the <code>switch</code> statement
below, and of course link the adaptor to the core engine at link time.
<piece>
typedef struct adaptor_info * (ADAPTOR_INFO_FN) (void);
ADAPTOR_INFO_FN DSREP_localxml_get_info;
ADAPTOR_INFO_FN PDREP_localxml_get_info;
ADAPTOR_INFO_FN USER_localxml_get_info;
ADAPTOR_INFO_FN PERMS_localxml_get_info;
ADAPTOR_INFO_FN TASKINDEX_stdout_get_info;
ADAPTOR_INFO_FN ACTION_wftk_get_info;
ADAPTOR_INFO_FN ACTION_system_get_info;
ADAPTOR_INFO_FN DATASTORE_role_get_info;
ADAPTOR_INFO_FN DATASTORE_currecord_get_info;
ADAPTOR_INFO_FN DATATYPE_option_get_info;
</piece>

And now the function itself.

<piece>
WFTK_ADAPTOR * config_get_adaptor (void * session, int adaptor_class, char * adaptor_descriptor, int name_length)
{
   char namebuf[64];
   struct loaded_library * library;
   ADAPTOR_INFO_FN * func;
   struct adaptor_info * ai = (struct adaptor_info *) 0;
   char * dll_start = "";

   WFTK_ADAPTOR * ret;

   switch (adaptor_class) {
      case DSREP:
         dll_start = "DSREP_";
         if (!name_length || (name_length == 8 && !strncmp ("localxml", adaptor_descriptor, 8))) {
            ai = DSREP_localxml_get_info();
         }
         break;
      case DATASTORE:
         dll_start = "DATASTORE_";
         if (name_length == 4 && (!strncmp ("role", adaptor_descriptor, 4))) {
            ai = DATASTORE_role_get_info();
         }
         if (name_length == 9 && (!strncmp ("currecord", adaptor_descriptor, 9))) {
            ai = DATASTORE_currecord_get_info();
         }
         break;
      case DATATYPE:
         dll_start = "DATATYPE_";
         if (name_length == 6 && (!strncmp ("option", adaptor_descriptor, 6))) {
            ai = DATATYPE_option_get_info();
         }
         break;
      case PDREP:
         dll_start = "PDREP_";
         if (!name_length || (name_length == 8 && !strncmp ("localxml", adaptor_descriptor, 8))) {
            ai = PDREP_localxml_get_info();
         }
         break;
      case USER:
         dll_start = "USER_";
         if (!name_length || (name_length == 8 && !strncmp ("localxml", adaptor_descriptor, 8))) {
            ai = USER_localxml_get_info();
         }
         break;
      case PERMS:
         dll_start = "PERMS_";
         /* Perms are different -- the caller gets no choice.
            Otherwise I figure we're in trouble, security-wise.
            Probably are anyway. */
         ai = PERMS_localxml_get_info();
         break;
      case TASKINDEX:
         dll_start = "TASKINDEX_";
         if (name_length == 6 && !strncmp ("stdout", adaptor_descriptor, 6)) {
            ai = TASKINDEX_stdout_get_info();
            break;
         }
         if (!name_length) {  /* The default not being a static link, we have to check the config for an explicit name. */
            adaptor_descriptor = (char *) config_get_value (session, "taskindex.default");
            if (strchr (adaptor_descriptor, ':')) name_length = strchr (adaptor_descriptor, ':') - adaptor_descriptor;
            else                                  name_length = strlen (adaptor_descriptor);
         }
         break;
      case NOTIFY:
         dll_start = "NOTIFY_";
         if (!name_length) {
            adaptor_descriptor = (char *) config_get_value (session, "notify.default");
            if (strchr (adaptor_descriptor, ':')) name_length = strchr (adaptor_descriptor, ':') - adaptor_descriptor;
            else                                  name_length = strlen (adaptor_descriptor);
         }
         break;
      case ACTION:
         dll_start = "ACTION_";
         if (name_length == 6 && !strncmp ("system", adaptor_descriptor, 6)) {
            ai = ACTION_system_get_info();
            break;
         }
         if (!name_length || (name_length == 4 && !strncmp ("wftk", adaptor_descriptor, 4))) {
            ai = ACTION_wftk_get_info();
         }
         break;
      case DEBUG_MSG:
         dll_start = "DEBUG_MSG_";
         break;
      default:
         return (WFTK_ADAPTOR *) 0;
   }

   if (!ai #^7#^7 name_length) { /* The adaptor isn't statically linked, anyway.  Let's try finding it dynamically, if it's named. */
      /* Is this DLL already loaded?  Check the loaded list. */
      library = loaded_libraries;
      strncpy (namebuf, adaptor_descriptor, name_length);
      while (library) {
         if (adaptor_class == library->adaptor_class #^7#^7 !strcmp (namebuf, library->adaptor)) {
            ai = library->ai;
            break;
         }
         library = library->next;
      }

#ifdef WINDOWS
      if (!ai) {
         /* Look for a properly named DLL.  When I figure out dynaloading under Unix this will expand. */
         library = (struct loaded_library *) malloc (sizeof (struct loaded_library));
         library->adaptor_class = adaptor_class;
         strcpy (library->adaptor, namebuf);
         strcpy (namebuf, dll_start);
         strncat (namebuf, adaptor_descriptor, name_length);
         strcat (namebuf, ".dll");
         library->inst = LoadLibrary (namebuf);
         if (!library->inst) {
            config_debug_message ('A', "Failed to load library %s.\n", namebuf);
            free (library);
            return NULL;
         }
         strcpy (namebuf, dll_start);
         strncat (namebuf, adaptor_descriptor, name_length);
         strcat (namebuf, "_get_info");
         func = (ADAPTOR_INFO_FN *) GetProcAddress (library->inst, namebuf);
         if (!func) {
            config_debug_message ('A', "Adaptor doesn't export %s.\n", namebuf);
            free (library);
            return NULL;
         }
         ai = (*func) ();
      }
#endif
   }
   if (!ai) return (WFTK_ADAPTOR *) 0; /* No luck. */

   ret = (WFTK_ADAPTOR *) malloc (sizeof (struct wftk_adaptor) + ai->nfuncs * sizeof (void *));
   if (!ret) return (WFTK_ADAPTOR *) 0;

   ret->num     = adaptor_class;
   ret->parms   = (void *) 0;     /* This will be filled in by the caller. */
   ret->nfuncs  = ai->nfuncs;
   ret->names   = ai->names;
   ret->vtab    = ai->vtab;
   ret->session = session;
   return (ret);
}
</piece>

And we need a very similar function in order to return adaptor lists.  Note that for adaptor lists, we don't bother with
all the adaptor classes, because many of them don't even make sense used that way.  Adaptor lists are only used for
notification-like functions (task index, debug messager, etc.)

<piece>
WFTK_ADAPTORLIST * config_get_adaptorlist (void * session, int adaptor_class)
{
   const char * spec = "";
   int adaptors = 1;
   int i;
   const char * mark;
   char * mark2;
   char adaptorbuffer[256]; /* TODO: another dang static buffer.  Fix it. */
   WFTK_ADAPTORLIST * list;

   switch (adaptor_class) {
      case TASKINDEX:
         spec = config_get_value (session, "taskindex.always");
         break;
      case NOTIFY:
         spec = config_get_value (session, "notify.always");
         break;
      default:
         return (WFTK_ADAPTORLIST *) 0;
   }

   if (!*spec) return (WFTK_ADAPTORLIST *) 0;

   /* First pass: count semicolons, so we know how large a list structure to allocate. */
   mark = spec;
   do {
      mark = strchr (mark, ';');
      if (!mark) break;
      adaptors++; mark++;
   } while (mark);

   list = (WFTK_ADAPTORLIST *) malloc (sizeof (WFTK_ADAPTOR_LIST) + adaptors * sizeof (WFTK_ADAPTOR *));
   list->count = adaptors;

   for (i=0, mark = spec; i < adaptors; i++) {
      strcpy (adaptorbuffer, mark);
      mark = strchr(mark, ';');
      if (mark) { mark++; while (*mark == ' ') mark++; }
      mark2 = strchr (adaptorbuffer, ';');
      if (mark2) *mark2 = '\0';

      list->ads[i] = wftk_get_adaptor (session, adaptor_class, adaptorbuffer);
   }

   return (list);
}
</piece>

OK, with that out of the way, let's look at a simple function to return named values.
Since these named values will be constant, I'm going to take the cheap way out and just return pointers.  This means that
if the pointer is used to write, the workflow system is not going to react in a happy, friendly way, but it's so much
simpler to work with this way.
<p/>
Some of the named values we use will be required only by specific adaptors, so I don't think it makes sense simply to
number them.  So instead of a nice clean <code>switch</code> we need a bunch of string comparisons.  Sorry.  The smarter
config module will presumably just pass this off to some API (the canonical one being the Windows Registry, of course.)
<p/>
This function itself uses the definitions in the localdefs.h file.  That seems weird -- why not just include the values
right here? -- but it's more natural to look for config values in a .h file than in a .c file, so I think that makes more
sense for the time being.  At any rate, with any luck that's going to be superseded relatively quickly anyway.  Right?
<p/>
And wow -- I superseded it before I even finished the release.  It was just too stupid.  The compiled values will still
be there as fallbacks in case you want to run <i>sans</i> config.xml, but we'll go ahead and read config.xml.
<piece>
XML * config_find_option (XML * xml, const char * name) {
   int len;
   XML * x;
   char * mark = strchr (name, '.');

   if (mark) len = mark - name;
   else      len = strlen (name);

   x = xml_firstelem (xml);
   while (x) {
      if (!strncmp (xml_attrval (x, "name"), name, len) ||
          !strncmp (xml_attrval (x, "id"), name, len)   ||
          !strncmp ("?", name, len)) {
         if (mark) {
            return (config_find_option (x, mark + 1));
         }
         return (x);
      }
      x = xml_nextelem (x);
   }
   return NULL;
}
XML * config_get_option (void * session, const char * valuename) {
   WFTK_SESSION * sess = session;
   if (sess) {
      if (sess->config) {
         return (config_find_option (sess->config, valuename));
      }
   }
   return NULL;
}
const char * config_get_value (void * session, const char * valuename) {
   XML * mark = config_get_option (session, valuename);
   if (mark) return (xml_attrval (mark, "value"));

   if (!strcmp (valuename, "pdrep.localxml.directory")) return PROCDEF_DIRECTORY;
   if (!strcmp (valuename, "dsrep.localxml.directory")) return DATASHEET_DIRECTORY;
   if (!strcmp (valuename, "user.localxml.directory")) return USER_DIRECTORY;
   if (!strcmp (valuename, "group.localxml.directory")) return GROUP_DIRECTORY;
   if (!strcmp (valuename, "taskindex.odbc.?.conn")) return ODBC_CONNECTION;
   return "";
}
</piece>

Was that too weird?  I'm sure it'll make sense later.
<p/>

Finally, the debugging message handler.  In this first version, I'm going to get dumb (duh) and simply write to stdout.
Later we can refine this, with debug logging and stuff.  And later still we can get fancy.
<piece>
void config_debug_message (char type, const char * message, ...)
{
   va_list arglist;

   va_start (arglist, message);
   printf ("DEBUG %c:", type);
   vprintf (message, arglist);
   printf ("\n");
   va_end (arglist);
}
</piece>

</item>


</litprog>


