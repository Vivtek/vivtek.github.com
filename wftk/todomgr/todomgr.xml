<litprog>

<object name="todomgr.tcl" item="main"/>
<object name="schema.sql" item="schema"/>

<item name="main" label="File organization of todomgr.tcl">
Most people are familiar with the Apache/CGI model of active content, where an action is
defined as a file (the CGI program) which is activated when selected via URL.  AOLserver
does things a little differently.  Well, you can do things that way by putting your Tcl
code into a plain ol' Tcl file.  But I use the <i>ns_register</i> call to define some
URLs as active URLs, and tell the server what Tcl procedure to call when a request is
made to that URL.  It's a slick mechanism.
<p>
AOLserver/Tcl code of this type consists of calls to <code>ns_register</code>, perhaps some
settings for global variables, and <code>proc</code> definitions.
<p>
Let's start our file off with a little copyright info:
<piece>
# To-do manager, take 1.
# Copyright (c) 2000, Vivtek.
# Released under the terms of the GNU license.

</piece>

And let's set two globals: the home directory and the base URL for the application.  Oh, and
the database connection pool to use.

<piece>
set todomgr_home /usr/local/AOLserver/vivtek/pages/todomgr/
set todomgr_root /todomgr
set todomgr_pool wftk
</piece>

Now let's define the URLs we want to use:
<piece>
ns_register_proc GET  $todomgr_root/create todomgr_create
ns_register_proc POST $todomgr_root/create todomgr_create
ns_register_proc GET  $todomgr_root/start todomgr_start
ns_register_proc POST $todomgr_root/start todomgr_start
ns_register_proc GET  $todomgr_root/show todomgr_show
ns_register_proc POST $todomgr_root/show todomgr_show
ns_register_proc GET  $todomgr_root/complete todomgr_complete
ns_register_proc POST $todomgr_root/complete todomgr_complete
ns_register_proc GET  $todomgr_root/reject todomgr_reject
ns_register_proc POST $todomgr_root/reject todomgr_reject
ns_register_proc GET  $todomgr_root/update todomgr_update
ns_register_proc POST $todomgr_root/update todomgr_update

ns_register_proc GET  $todomgr_root/overview todomgr_overview
</piece>

(Notice that in Tcl you don't have to enclose strings in quotes if the interpreter can figure
things out from context.  This causes me no end of grief when coding Perl.)
<p>
And let's go ahead and define each of our procedures that we're referring to up there.  The
bodies of these procedures will be filled in later.
<piece>
proc todomgr_create {conn ignore} {
  <insert name="todomgr_create"/>
}

proc todomgr_start {conn ignore} {
  <insert name="todomgr_start"/>
}

proc todomgr_show {conn ignore} {
  <insert name="todomgr_show"/>
}

proc todomgr_complete {conn ignore} {
  <insert name="todomgr_complete"/>
}

proc todomgr_reject {conn ignore} {
  <insert name="todomgr_reject"/>
}

proc todomgr_update {conn ignore} {
  <insert name="todomgr_update"/>
}

proc todomgr_overview {conn ignore} {
  <insert name="todomgr_overview"/>
}
</piece>

And there are a few utility functions that I'll be using throughout:
<code>todomgr_pageout</code> is what I'll use to write pages, and there are some others in the
final section of the presentation.

<piece>
<insert name="pageout"/>
<insert name="util"/>
<insert name="user_admin"/>
<insert name="login_admin"/>
<insert name="keywords"/>
<insert name="wftk_interpret"/>
</piece>

<i>(5/10/2000)</i> Let's toss in a couple more procs to deal with datasheet manipulation (the
getting and setting of values attached to the process and to tasks.)

<piece>
<insert name="datasheet_stuff"/>
</piece>

</item>

<item name="schema" label="Database schema of the task list">
The task list is wftk's <i>active process repository</i>.  It consists of two tables; one
defines projects, the other tasks.  My epiphany about the relationship of wftk to a general
task management tool came when I realized that tasks can exist without projects perfectly
well.
<p>
This schema works on PostgreSQL.  Nothing fancy, and I'm omitting DBA details like indexing
and the like; I just want to define the fields we'll need.  Let's call our tables "process"
and "task", yeah, those are fairly descriptive.  Translation of this schema to other SQL
dialects should be relatively straightforward, as most of the fields are just character data
anyway (one of the things I like about PostgreSQL is that I don't have to feel guilty
about text fields, or pretend that I can project meaningful size boundaries onto them.)
<p>
Besides the task and process tables, I'm including a user table, which will probably be 
replaced at some point with a more sophisticated directory mechanism, and a keyword table.
The keyword table started out as an organizational mechanism completely extraneous to wftk,
but I realized that it's also an excellent place to store permissions linking users with
classes of task and process.  I'm not sure how much overlap that will end up having with 
workflow proper, but that's the whole purpose of doing a prototype.  (I'm approaching this
with the attitude of "Plan to throw one away; you will anyway."  I surely wish I knew the
attribution for that quote, because it's a good one.)
<p>
So here are the tables we'll be defining, all in all:

<piece>
create table process (
<insert name=".process">
);

create table task (
<insert name=".task">
);

create table user (
<insert name="user_schema">
);

create table keyword (
<insert name="perm_schema.keyword">
);

create table permission (
<insert name="perm_schema.permission">
);

</piece>

The schema I'm presenting here is meant to implement the necessary fields for wftk and those
for this to-do manager.  The nice thing about SQL, of course, is that properly written SQL
interface code can deal with views onto the data (so that you can tack other stuff onto whatever
table you like and things won't break.)  Don't feel overly constrained by these definitions.
(This is turning into my mantra: don't feel constrained by any of my coding decisions!)
</item>

<item name="schema.process" label="Process table">
The process table will actually not be used very heavily for to-do management.  The only place
we care about this table will be in the overview, when we'll use it to group tasks by process
(or "project").  Nevertheless, this presentation is also an implementation of the wftk
active process repository, so let's take a look at what we'll need in there.

<piece>
id text,
owner text,
title text,
description text,
started timestamp,
parent_process text,
parent_task text,
definition text,
datasheet text,
status text

</piece>

OK, let's run down the list and I'll tell you what each of those is for.
<ul>
<b><li> owner</b>: the user who owns the process.<br>
There are two basic ways that processes get created; either the wftk engine creates them when
a definition is activated, or a user creates a process manually using the to-do manager.  In
the latter case, the user's id is used as "owner"; in the former, we'll see what makes sense.
In some cases, it makes sense for the initiating user to be the owner, but if a process is
initiated anonymously (say, in response to an HTTP form submission) then the owner of the
process definition will probably be used.  We'll see what makes sense later.

<br>
<b><li> title, description</b>: short and long description of the project for reporting.<br>
For a manual process, these are obvious.  For a wftk-initiated process, they may be superfluous.
Again, only banging on a prototype will answer that question.  Certainly we'll need a title
in place in order for the to-do manager and other UI components to have something to display.
I certainly don't want to have to retrieve the definitions of all active processes in order
to create an activity report, for instance.

<br>
<b><li> started</b>: date the process was created.<br>
Enough said.  Obviously applies to both categories of process.

<br>
<b><li> parent_process, parent_task</b>: parent information.<br>
If this is a subprocess, then it might require different handling.  Certainly when it completes,
then its parent task must also be completed.  The task ID would logically be unique, but I
have a nasty habit of programming defensively.

<br>
<b><li> definition</b>: location (URL, presumably) of the process definition.<br>
This is only meaningful in the context of wftk, of course.  The process definition is used by
the wftk core engine to determine what comes next when a task is completed or rejected.

<br>
<b><li> datasheet</b>: location of the datasheet for the process.<br>
The datasheet module is of course a wftk module -- but could be used quite nicely independently
of wftk.  It's a place to stash data associated with a process.  (Note that the task also has
a datasheet location.  By default these locations will be identical.)

<br>
<b><li> status</b>: state of the process.<br>
I guess pending, active, completed, aborted would be logical states.  Anybody have any
suggestions?
</ul>

</item>

<item name="schema.task" label="Task table">
The task table is similarly overloaded.  I think I'm getting somewhat carried away about
everything I want to attach to tasks, but this will do for a first run.

<piece>
id text,
process text,
status text,
owner text,
description text,
role text,
queue text,
created timestamp,
sched_date date,
sched_time time,
priority smallint,
complete timestamp,
datasheet text,
subprocess text

</piece>

These are as follows.
<ul>
<b><li> process</b>: the ID of the process this task belongs to (if any).<br>
If the user has manually created a task with the to-do manager, then there needn't be any
process associated at all.  For manual tasks, the process is effectively nothing more than an
organizational mechanism (i.e. it's there for the description fields and to group on.)

<br>
<b><li> status</b>: the status of the task.<br>
Pending, active, complete, rejected, and request.  A
 "pending" task is one which has been added by the
wftk engine, but is either not yet assigned to a user or has simply not yet been activated.  If
I have a pending task already assigned to me, then I can see it in my to-do list, and can set
scheduling information for it.  I just can't actually complete it until it's active.  If the 
status is "request", this is a manually created task which another user has created for me.
I can either reject it or accept it; if accepted, the task becomes active.

<br>
<b><li> owner</b>: the user assigned to the task.<br>
In the case of a manually created task, this is the person who created the task.  If I create
a task for another user, that is really not a task, but a request -- the cleanest way to 
implement this would be to provide a new status "request".  Then the request would have to have
attached data to describe it, and that would require a datasheet module, but that's life in the
big city.  In the case of a task which has not yet been assigned, "owner" will be blank and
"role" and/or "queue" will be filled in instead.

<br>
<b><li> description</b>: a short description of the task.<br>
In the case of a manual entry, the user simply types in some description of the task.  For
wftk usage, the engine will create a description based on particulars of the task.

<br>
<b><li> role</b>: the process role associated with the task.<br>
This has meaning only in the wftk process; it's the role in the process definition which the
user will be fulfilling during this task.  The chief reason to have it here is to facilitate
reassignment should the task be rejected.

<br>
<b><li> queue</b>: the queue on which the task resides.<br>
For queueing of tasks and requests.  This is still rather inchoate but I just have the
intuition that I'm going to need it.  It's not used by wftk.

<br>
<b><li> created</b>: the date the task was created.<br>
Useful for implementing queues.  Not needed by wftk.

<br>
<b><li> sched_date, sched_time</b>: date and time of scheduled start.<br>
This is completely ignored by wftk.  It's used for reporting and for organization of the
individual's to-do lists.  Also makes it nice for representing appointments as tasks.

<br>
<b><li> priority</b><br>
This is where I'm not sure if I'm getting out of control with feeping creaturism.  I think that
this will be necessary, at least for implementation of priority queues, and also for individual
to-do list organization, but I'm not sure where the line should be drawn.

<br>
<b><li> completed</b>: date of completion.

<br>
<b><li> datasheet</b>: link into datasheet.<br>
This is the location where values associated with the task (or request) are stored.  This will
all make sense later, I promise.  Since this module isn't implemented yet, though, there's not
a lot of point in pontificating.

<br>
<b><li> subprocess</b>: subprocess ID.<br>
If this task is being implemented by a subprocess, then the ID of that subprocess is here.

</ul>

</item>

<item name="user_schema" label="Schema for user access">
The user table, as indicated, has a sort of temporary aspect for me.  But I need it implemented
in order to get a prototype demo off the ground, so here it is.  It will probably be replaced
by some directory module or something as soon as I figure out how all that works.
<piece>
userid text,
password text,
permlevel smallint,
name text,
email text,
website text
</piece>

Here are what the fields are supposed to be for:<ul>
<b><li>userid, password</b> - obvious.<br>
The password will be plaintext for this demo just to cut corners.  Not a very valid long-term
solution, but it's quick.
<p>
<b><li>permlevel</b><br>
The level of access of the user to the whole task list manager.  Allowed values are: 0 - inactive
user (in case I want to block somebody but not lose the contact info), 1 - viewer only, and 2 -
full access.  Full access just means that this user may own tasks and processes.  The detailed
privileges of a viewer-level user are granted with the keyword/permission system (in the next
section.)  Privileges of a level-2 user to processes owned by other people are likewise
governed by the permission system.
<p>
In the demo system, the "demo" user is a level-2 user.  This means that people trying out the
demo can create their own tasks and processes in order to see how the system works.  They also
have viewer-level access to the wftk processes.
<p>
<b><li>name, email, website</b><br>
Since this particular implementation is aimed at being a demo, these three contact information
fields seem logical.  Obviously anything could be tossed in here as contact info, and this UI
wouldn't care about it.
</item>

<item name="perm_schema" label="Permissions schema">
The permissions facility is used to grant users access to projects that they don't own.  A
project may be associated with any number of keywords, and a user may have permissions to any
number of keywords.  The permission mechanism permits fairly fine-grained control over who can
do what, as this part of the application is really aimed at granting my own customers varying
degrees of access to my own to-do list.  So I want some of them to be able to modify the
priorities of their own category of tasks, for instance, but I don't want them to be able to
rename tasks.
<p>
The tables we need for this are pretty easy: just a keyword table which associates a keyword
with a project, and a permission table which grants a user various privileges to a given keyword.
If no permission is given to a user for a given keyword, projects using that keyword will be
completely invisible to the user.  (Unless the project has more than one keyword and the user
has viewing privilege to another applicable keyword.)
</item>

<item name="perm_schema.keyword" label="Keyword table">
The keyword table is very simple:
<piece>
process text,
keyword text
</piece>
</item>

<item name="perm_schema.permission" label="Permission table">
The permission table is a little trickier.  When working in Tcl I usually use a string for
flags of this nature, then do a <code>[string match *b* $string]</code> or something to look
for the 'b' flag.  As the only question which really impacts queries is whether or not <i>any</i>
permission exists, I see no need to use Booleans.

<piece>
userid text,
keyword text,
flags text
</piece>

The flags I will define are:<ul>
<b><li>p</b> - assign keyword.  To assign a process to a keyword, I must own the process
               or have 'p' privilege.  To assign a keyword to a user, I must own or have
               'p' privileges to <i>all</i> the processes associated with the keyword.
<b><li>t</b> - request a task.
<b><li>r</b> - modify priority.
<b><li>m</b> - modify anything including priority.
</ul>

There is no flag for viewing privileges, because mere existence of the keyword grants that (the
query is easier that way.)
<p>
Task requests can be made by any user who has viewing privileges on a project.  The requestee
must be (at least) level 2 and likewise have viewing privileges on the project.  The task
requested is <i>not</i> active until the new owner accepts it; a request may also be foisted
off on someone else.  Logically a request could be made of a role or queue as well, but I
haven't implemented roles and queues yet, so that will have to wait.
</item>


<item name="todomgr_create" label="Definition of todomgr_create">
The <code>/create</code> URL is used both to present a form for task creation, and actual
creation of the task.  It also handles the same thing for processes.
<p>
Before we do anything else, we need to get a database handle and check the authorized user.
This is pretty straightforward.  Note that in AOLserver/Tcl the <code>ns_db</code>
command connects us with the excellent DB interface.  The DB interface opens and
manages a pool of connections, and we simply select one (or more) when needed.  When the
HTTP transaction terminates, the connections are returned to the pool.
<piece>
global todomgr_pool
set db [ns_db gethandle $todomgr_pool]
<insert name="user.check"/>
</piece>

The next thing to do is to check the form input.  In AOLserver/Tcl, this is done for you
before your proc is ever called (contrast with the irritation of having to do it yourself in
CGI.  Yes, I know there are libraries.)  All kinds of information is available with the
<code>ns_conn</code> command.  The form in question is query string information (preparsed)
for GETs, and content body information (also preparsed) for POSTs.  It's returned as an
<code>ns_set</code> datastructure which does pretty much what Perl hashes do.
<p>
If the form is blank, we know we're not actually creating
anything, so we present the creation form.

<piece>
set form [ns_conn form $conn]
if {$form == ""} {
  <insert name=".freshform">
  return
}
</piece>

If the form isn't blank, then we have to create either a process or a task.  Which?  (If neither,
let's return a nasty error message for the script kiddy trying to crack into the system.)

<piece>
if {[ns_set get $form what] == "task"} {
  if ![string compare [ns_set get $form description] ""] {
    <insert name=".newtask"/>
  } else {
    <insert name=".task"/>
  }
} elseif {[ns_set get $form what] == "process"} {
  if ![string compare [ns_set get $form title] ""] {
    <insert name=".newprocess"/>
  } else {
    <insert name=".process"/>
  }
} else {
  set tags(title) "Invalid create request"
  set tags(body) "
To create a task, use [[code>what=task[[/code>; for a process use [[code>what=process[[/code>.
You entered [[code>what=[ns_set get $form what][[/code>."

  todomgr_pageout $conn message.html
}

</piece>

And that's it.  Oh.  Still haven't covered any details.
</item>

<item name="todomgr_create.freshform" label="Show process/task creation form">
The display of a form is pretty straightforward.  AOLserver/Tcl provides the
<code>ns_return</code> function (among a couple of others) to perform this task.  While
we can obviously use a string and embed all the HTML right in the code here, I don't like
that style.  I nearly always use a template HTML file which I can then modify appropriately
with code.  Using that mechanism here means essentially copying the HTML file and writing it
out, so this begs the question of why we put it into this code in the first place instead of
simply directing the user to the HTML page directly.  Simple: we want a list of existing
projects to show up in the task creation form, and that happens in this code  and is made
ready in the tag <code>[##projectlist##]</code>.

<p>
This all makes use of the function <code>todomgr_pageout</code>, which will be defined later.
(If I were using a more mature literate programming tool, 
a link could automagically be inserted.  Unfortunately that's not the case.)

The query I'm using to grab processes is overly simplistic.  I'm not using user information yet.
I'll revisit this piece later so that the system will be multiuser.

<piece>
set row [ns_db select $db "select * from process"]
set tags(processlist) "[[option value=\"\">Select a process if applicable\n"
while {[ns_db getrow $db $row]} {
   append tags(processlist) "[[option value=\"[ns_set get $row id]\">[ns_set get $row title]\n"
}
todomgr_pageout $conn fresh_task.html

</piece>

</item>

<item name="todomgr_create.newtask" label="Requesting a task for a process">
If we know the process we're attaching a task to, then we have another form to use.  We have
to get some information about the project (basically its title) and we provide a list of
users to make the request of.  (The current user is the default.)  We also need to check
the user's permission level to make sure he/she may add tasks to the process.
<p>
First, if no process is involved (i.e. this is a standalone task) then we'll just present
the form and go on.
<piece>
set process [ns_set get $form process]
if ![string compare "" $process] {
   return [todomgr_pageout $conn newtasknoproc.html]
} 
</piece>

Now let's get info about the process and make sure it exists.
<piece>
set tags(process) $process
set prow [ns_db select $db "select * from process where id='[sql_safe_string $process]'"]
if ![ns_db getrow $db $prow] {
   set tags(title) "Can't create task for nonexistent process"
   set tags(body) "The process code you entered (<code>$process</code>) can't be found in the database."
   return [todomgr_pageout $conn message.html]
}
set tags(title) [ns_set get $prow title]
</piece>

Next, let's check the user's permission level and ensure that it's sufficient.  Since the 
permission may come through any keyword, we have to check all the keywords for the process.

<piece>
if [string compare $user [ns_set get $prow owner]] {
   set perm 0
   set row [ns_db select $db "select * from keyword, permission where keyword.process='[sql_safe_string $process]' and keyword.keyword=permission.keyword and permission.userid='[sql_safe_string $user]'"]
   while {[ns_db getrow $db $row]} {
      if [string match *t* [ns_set get $row flags]] { set perm 1 }
   }
   if !$perm {
      set tags(body) "You don't have sufficient privileges to request tasks for [[i>$tags(title)[[/i>"
      set tags(title) "Insufficent privilege"
      return [todomgr_pageout $conn message.html]
   }
}
</piece>

OK, let's build our list of users of which we can make requests, and put up the form.

<piece>
set    query "select * from keyword, permission, users "
append query   "where keyword.process='[sql_safe_string $process]' "
append query     "and keyword.keyword=permission.keyword and permission.userid=users.userid "
append query     "and users.permlevel > 1"
append query " order by name"

set row [ns_db select $db $query]
set tags(userlist) "[[option value=\"$user\">Select a requestee here\n"
while {[ns_db getrow $db $row]} {
   append tags(userlist) "[[option value=\"[ns_set get $row userid]\">"
   append tags(userlist) "[ns_set get $row name] ([ns_set get $row userid])\n"
}
 
todomgr_pageout $conn newtask.html
</piece>

</item>

<item name="todomgr_create.task" label="Create task">
Once we've presented the form and the user has filled it in, we come to the task creation
routine.
The first thing is to build a task ID.  We want to make sure it's unique;
in AOLserver/Tcl a useful way of
doing that is to use the connection handle (which is a string, this is Tcl after all) and the
current time.  The <code>now</code> function is one I use a lot; its definition is in the
utility section.
<piece>
set task $conn[now tag]
</piece>

Next, we build our SQL statement to create the task requested and execute that statement.
<piece>
set fields [list id status created]
set values [list '$task' 'active' '[now]']
foreach field {process description priority sched_date sched_time} {
   if {[ns_set find $form $field] == -1} { continue }
   if {[ns_set get $form $field] == ""} { continue }

   lappend fields $field
   if {$field == "priority"} {
      lappend values [ns_set get $form $field]
   } else {
      lappend values "'[sql_safe_string [ns_set get $form $field]]'"
   }
}

if {[lsearch $fields owner] == -1} {
   lappend fields owner
   lappend values "'[sql_safe_string $user]'"
}

set query "insert into task ("
append query [join $fields ", "]
append query ") values ("
append query [join $values ", "]
append query ")"

ns_db dml $db $query

ns_returnredirect $conn show?task=$task
</piece>

And that's it.  Our task is created.  Notice that instead of doing any display here, I'm just
returning a redirect so that all task display is concentrated into one area.
</item>

<item name="todomgr_create.newprocess" label="Requesting a new process">
This is no more than presenting the form.
<piece>
return [todomgr_pageout $conn newprocess.html]
</piece>
</item>

<item name="todomgr_create.process" label="Create process">
Creating a process is almost identical to creation of a task.  The fields are different, that's
all.  And since we have no numeric fields in the process record, we don't need that special
logic to avoid putting quotes around the priority field that we needed in the task record.
<piece>
set process $conn[now tag]
set fields [list id status started]
set values [list '$process' 'pending' '[now]']
foreach field {title description} {
   if {[ns_set find $form $field] == -1} { continue }
   if {[ns_set get $form $field] == ""} { continue }

   lappend fields $field
   lappend values "'[sql_safe_string [ns_set get $form $field]]'"
}

if {[lsearch $fields owner] == -1} {
   lappend fields owner
   lappend values "'[sql_safe_string $user]'"
}

set query "insert into process ("
append query [join $fields ", "]
append query ") values ("
append query [join $values ", "]
append query ")"

ns_db dml $db $query

ns_returnredirect $conn show?process=$process
</piece>

</item>


<item name="todomgr_start" label="Definition of todomgr_start">
The <code>/start</code> URL is used to start workflow processes.  (This is in contrast to
ad-hoc processes, which are not managed by the workflow engine, but rather simply serve as
a hook to hang tasks on which are then completed in arbitrary order.)
<p>
<piece>
global todomgr_pool
global todomgr_home
set db [ns_db gethandle $todomgr_pool]
<insert name="user.check"/>
</piece>

Now that that's done, we can check our form input to see what we're actually supposed to
be doing.  If we have an input "procdef" then we should show the starter form; if we have
"start" and "ver" then we should call pdm to create a datasheet, add the process to the
database, and ask wftk to start the process for us.

<piece>
set form [ns_conn form $conn]
if {$form == ""} { set form [ns_set create] }

if [string compare "" [ns_set get $form procdef]] {
   <insert name=".startform"/>
}
if [string compare "" [ns_set get $form start]] {
   <insert name=".start"/>
}

<insert name=".showlist"/>
</piece>
</item>

<item name="todomgr_start.showlist" label="Show list of available procdefs">

<piece>
set pipe [open "|$todomgr_home/pdm list start?procdef=%s" "r"]
set tags(list) [read $pipe]
close $pipe

return [todomgr_pageout $conn startlist.html]
</piece>
</item>

<item name="todomgr_start.startform" label="Show start form for specified procdef">

<piece>
set tags(procdef) [ns_set get $form procdef]
set pipe [open "|$todomgr_home/pdm starter $tags(procdef)" "r"]
set tags(title) [gets $pipe]
set tags(version) [gets $pipe]
set tags(list) [read $pipe]
close $pipe

return [todomgr_pageout $conn start.html]
</piece>
</item>

<item name="todomgr_start.start" label="Actually starting a new process from a procdef">

<piece>
set process $conn[now tag]
global todomgr_datasheets
set pipe [open "|${todomgr_home}pdm datasheet [ns_set get $form start] [ns_set get $form ver] $process" "r"]
set datasheet [read $pipe]
close $pipe

set pipe [open "$todomgr_datasheets/$process" "w"]
puts $pipe $datasheet
close $pipe

set size [ns_set size $form]
for {set i 0} {$i < $size} {incr i} {
   if {-1 < [lsearch {start ver} [ns_set key $form $i]]} { continue }
   datasheet_setvalue $process "" [ns_set key $form $i] "" [ns_set value $form $i]
}

set pipe [open "|${todomgr_home}wftk start $process" "r"]
set workflow [read $pipe]
close $pipe

set wf [split $workflow \n]

set fields [list id status started]
set values [list '$process' 'active' '[now]']

lappend fields title
set title [string range [lindex $wf 0] 2 end]
lappend values "'[sql_safe_string $title]'"

set wf [lrange $wf 2 end]
while {![string compare "" [lindex $wf 0]]} { set wf [lrange $wf 1 end] }

set desc ""
while {[string compare EOF [lindex $wf 0]]} {
   append desc "[lindex $wf 0]<br>"
   set wf [lrange $wf 1 end]
}
set wf [lrange $wf 1 end]

lappend fields description
lappend values "'[sql_safe_string $desc]'"

lappend fields owner
lappend values "'[sql_safe_string $user]'"

lappend fields definition
set procdef "[ns_set get $form start]_[ns_set get $form ver].xml"
lappend values "'[sql_safe_string $procdef]'"

lappend fields datasheet
lappend values "'$process'"

set query "insert into process ("
append query [join $fields ", "]
append query ") values ("
append query [join $values ", "]
append query ")"

ns_db dml $db $query

wftk_interpret $db $process $wf

return [ns_returnredirect $conn overview?process=$process]
</piece>
</item>


<item name="todomgr_show" label="Definition of todomgr_show">
Like the create routine, the show routine is also responsible for both tasks and processes,
and we can tell which is which by looking at the key given us (<code>task=something</code>
versus <code>process=something</code>).  First let's get the form and complain if there is
none.
<piece>
set form [ns_conn form $conn]
if {$form == ""} {
   set tags(title) "Nothing to show"
   set tags(body) "You need to select something to show."
   return [todomgr_pageout $conn message.html]
}
global todomgr_pool
set db [ns_db gethandle $todomgr_pool]
<insert name="user.check"/>
</piece>

OK, now let's look at the <code>back</code> parameter.  If that's there, then we're coming in
from one of the list views and we want to offer the user the option of going back to the list
after an update operation.  Otherwise, updates will come back here.

<piece>
set back [ns_set get $form back]
if [string compare $back ""] {
   set tags(back) "[[input type=checkbox checked name=back value=\"$back\">"
   append tags(back) "Return to list after update"
} else {
   set tags(back) ""
}
append back "[ns_conn url $conn]?[ns_conn query $conn]"
append tags(back) "[[input type=hidden name=back value=\"$back\">\n"
</piece>

I'm getting a little tricky there; if the box is displayed, then if it's not checked it will
never appear in the query list for <code>update</code> and the hidden field (which directs
<code>update</code> back here to the display) will take control.  But if the box remains checked,
then its value will be the first in the query list, and <code>ns_set</code> will return that
value first when queried for "back".  So <code>update</code> will return to the list instead of
to this display screen.
<p>
OK, now that's out of the way, let's do some displaying.
We can display either a task or a process, and each of those
is shown detail below.  Here's the code we'll hang those in:
<piece>
set task [ns_set get $form task]
if {$task != ""} {
   <insert name=".task"/>
   return
}
set process [ns_set get $form process]
if {$process != ""} {
   <insert name=".process"/>
   return
}

set tags(title) "Nothing to show"
set tags(body) "You need to select something to show."
todomgr_pageout $conn message.html
</piece>

</item>

<item name="todomgr_show.task" label="Show task">
Showing a task (or any other single record from a database) is simple.  You just load the
record, toss the values into tags, and express the template.  (Since there are two modes
for task display, edit and view, there are two pageout calls.)

<piece>
if [catch {set row [ns_db select $db "select * from task where id='$task'"]} result] {
   set tags(title) "Task $task unknown"
   set tags(body) "The task ID <code>$task</code> is not in the database.  Sorry."
   return [todomgr_pageout $conn message.html]
}

if [ns_db getrow $db $row] {
   foreach field {process status priority owner description created sched_date sched_time} {
      set tags($field) [ns_set get $row $field]
   }
   set tags(task) $task
   if [string compare "edit" [ns_set get $form mode]] {
      <insert name="todomgr_show.getprocess"/>
      <insert name="todomgr_show.getowner"/>
      set tags(updatelink) ""
      set tags(isowner) 0
      if ![string compare $tags(owner) $user] {
         set tags(isowner) 1
         set tags(updatelink) "show?task=$task&back=$back&mode=edit"
         set tags(backhere) "[ns_conn url $conn]?[ns_conn query $conn]"
         set tags(taskdata) [datasheet_showdata edit $tags(backhere) $tags(processid) $task]
      }
      return [todomgr_pageout $conn taskhome.html]
   } else {
      <insert name="todomgr_show.makeprioritybox"/>
      <insert name="todomgr_show.getprocess"/>
      <insert name="todomgr_show.getowner"/>
      set tags(backhere) "[ns_conn url $conn]?[ns_conn query $conn]"
      set tags(taskdata) [datasheet_showdata view $tags(backhere) $tags(processid) $task]
      return [todomgr_pageout $conn task.html]
   }
} else {
   set tags(title) "Task $task unknown"
   set tags(body) "The task ID <code>$task</code> is not in the database.  Sorry."
   return [todomgr_pageout $conn message.html]
}
</piece>

That looks a little redundant, maybe; there are two different places where we apologize for a
missing record.  The first is as an error handler, while the second is after a null return.
This is due to a little oddity of the AOLserver PostgreSQL driver -- if a select returns no
rows, the driver flags that as an error.  However, other drivers don't act that way, so I need
the normal null-return error screen as well, just in case somebody is using a driver that
works sanely.  (Or in case anybody ever fixes the PostgreSQL driver.)
<p>
And of course you will have noticed that I slipped in a little extra processing besides the
standard "get the record, do the tags, return the page" list.  Let's take a look at that stuff.
</item>

<item name="todomgr_show.getprocess" label="Getting process info for task display">
What we want from the process table depends on what process the task belongs to.  If
it already is attached to a process, then we simply want the title of the process for
display and a link to display that process.  If this is a manually entered task, however,
which hasn't been attached to a
process, then we'll present a select box for that purpose.  I envision the situation as
this: as I'm entering tasks in my daily list, I realize that some of them group into a
process logically, so I create the process and want to add the (already existing) tasks
into it.  At the simplest level, then, a process is simply a group of tasks.
<p>
The list of processes which should appear in this list are those which the current user
owns, plus those for which the current user has 't' permission.
<p>
So let's check our process ID. 

<piece>
set process [ns_set get $row process]
set tags(processid) $process
if {$process != ""} {
   if [catch {set prow [ns_db select $db "select * from process where id='$process'"]} result] {
      set tags(process) "[[i>Unknown process $process[[/i>"
   } elseif [ns_db getrow $db $prow] {
      set p [ns_set get $prow title]
      set tags(process) "[[a href=\"overview?process=$process&who=all\">"
      append tags(process) "[ns_set get $prow title][[/a>"
   } else {
      set tags(process) "[[i>Unknown process $process[[/i>"
   }
} else {
   set    query "select id, title from process where owner='[sql_safe_string $user]' "
   append query "union "
   append query "select id, title from process, keyword, permission "
   append query   "where process.id=keyword.process and keyword.keyword=permission.keyword "
   append query   "  and permission.userid='[sql_safe_string $user]' "
   append query   "  and flags like '%t%'"
   append query " order by title"
   if [catch {set prow [ns_db select $db $query]} result] {
      set tags(process) "[[i>Unable to generate process list[[/i>"
   } else {
      set tags(process) "[[select name=process>\n"
      append tags(process) "[[option value=\"\">Select a process to assign\n"
      set lastid ""
      while {[ns_db getrow $db $prow]} {
         if ![string compare $lastid [ns_set get $prow id]] { continue }
         set lastid [ns_set get $prow id]
         append tags(process) "[[option value=\"[ns_set get $prow id]\">"
         append tags(process) "[ns_set get $prow title]\n"
      }
      append tags(process) "[[/select>\n"
   }
}
</piece>

</item>

<item name="todomgr_show.getowner" label="Getting owner info for task/process display">
Getting the owner's information is very similar to the process info, of course.  The only
real trick is that we're going to create a tag out of it called "ownertag" which will contain
a mailto: link and the user's ID and name.

<piece>
set owner $tags(owner) 
if {$owner != ""} {
   if [catch {set urow [ns_db select $db "select * from users where userid='$owner'"]} result] {
      set tags(ownertag) "[[i>Unknown owner $owner[[/i>"
   } elseif [ns_db getrow $db $urow] {
      if [string compare "" [ns_set get $urow email]] {
         set tags(ownertag) "[[a href=\"mailto:[ns_set get $urow email]\">"
      } else {
         set tags(ownertag) ""
      }
      append tags(ownertag) $owner
      if [string compare "" [ns_set get $urow email]] {
         append tags(ownertag) "[[/a>"
      }
      if [string compare "" [ns_set get $urow name]] {
         append tags(ownertag) " ([ns_set get $urow name])"
      }
   } else {
      set tags(ownertag) "[[i>Unknown owner $owner[[/i>"
   }
}
</piece>

</item>

<item name="todomgr_show.makeprioritybox" label="Making select box to change priority level">
This is pretty easy.  We have the priority level in <code>[ns_set get $row priority]</code>.
All we have to do is to make a select box which has a couple of priority levels above that.

<piece>
set tags(prioritybox) "[[select name=\"priority\">"
set p [ns_set get $row priority]
if {$p == ""} {
   append tags(prioritybox) "[[option value=\"\" selected>No priority selected\n"
   append tags(prioritybox) "[[option value=1>1\n"
   append tags(prioritybox) "[[option value=2>2\n"
   append tags(prioritybox) "[[option value=3>3\n"
} else {
   for {set i 1} {$i [[ $p} {incr i} {
      append tags(prioritybox) "[[option value=$i>$i\n"
   }
   append tags(prioritybox) "[[option value=$p selected>$p\n"
   incr p
   append tags(prioritybox) "[[option value=$p selected>$p\n"
   incr p
   append tags(prioritybox) "[[option value=$p selected>$p\n"
}
append tags(prioritybox) "[[/select>\n"
</piece>

And that's all there is to that.
</item>

<item name="todomgr_show.process" label="Show process">
Displaying a process really is as easy as I made it out to be above, since there are
no particularly special things we have to do.  But of course there is one little complication;
for processes I want to be able to get a list when I give <code>process=all</code> or 
<code>process=mine</code>.  These lists will link to individual process pages.

<piece>
if {![string compare $process all] || ![string compare $process mine]} {
   <insert name="todomgr_show.processlist"/>
}
if [catch {set row [ns_db select $db "select * from process where id='$process'"]} result] {
   set tags(title) "Process $process unknown"
   set tags(body) "The process ID <code>$process</code> is not in the database.  Sorry."
   return [todomgr_pageout $conn message.html]
}

if [ns_db getrow $db $row] {
   foreach field {title owner description started} {
      set tags($field) [ns_set get $row $field]
   }
   set tags(process) $process
   <insert name="todomgr_show.getowner"/>
   <insert name="todomgr_show.getkeywords"/>
   set tags(backhere) "[ns_conn url $conn]?[ns_conn query $conn]"
   set tags(processdata) [datasheet_showdata edit $tags(backhere) $process ""]
   return [todomgr_pageout $conn process.html]
} else {
   set tags(title) "Process $process unknown"
   set tags(body) "The process ID [[code>$process[[/code> is not in the database.  Sorry."
   return [todomgr_pageout $conn message.html]
}
</piece>
</item>

<item name="todomgr_show.getkeywords" label="Showing keywords for the process">
The list of keywords to present to the user depends on the user, not the process being
shown.  All keywords to which the user has permission should appear in the list.  If the
current user is the owner of the process, though, then even keywords to which the user
doesn't have permission should appear in the list.  (I think this is the right way to handle
this.  If you have more experience with security, tell me if this is reasonable.)
<p>
So display of keywords needs to happen in two phases.  First, we build an initial list using
all the keywords I have access to.  Then we scan all the keywords attached to the process.
If I own the process, then attached keywords may be added to the list; otherwise we only use
the second query to turn on the "used" flag for each visible keyword.
<p>
What we build for public consumption is a list of keywords with checkboxes for each one.
Keywords already associated with the process are checked; the others are not.  The whole
thing ends up in the <code>keywordlist</code> tag.  If the flags for a keyword include 'p',
then we'll additionally make the name of that keyword a link to the keyword management
screen (so that we can assign users, see the list of processes assigned to the keyword, and
so forth.)
<p>
One tricky point here: this code expects $tag(owner) to contain the owner of the project we're
looking at.
<piece>
set query "select * from permission where userid='[sql_safe_string $user]'"
set mgtwords [list]
if ![catch {set row [ns_db select $db $query]} result] {
   while {[ns_db getrow $db $row]} {
      set keyword([ns_set get $row keyword]) off
      if [string match *p* [ns_set get $row flags]] { lappend mgtwords [ns_set get $row keyword] }
   }
}
set query "select * from keyword where keyword.process='[sql_safe_string $process]'"
if ![catch {set row [ns_db select $db $query]} result] {
   if {[string tolower $user] == [string tolower $tags(owner)]} {
      while {[ns_db getrow $db $row]} {
         set keyword([ns_set get $row keyword]) on
      }
   } else {
      while {[ns_db getrow $db $row]} {
         if [info exists keyword([ns_set get $row keyword])] {
            set keyword([ns_set get $row keyword]) on
         }
      }
   }
}
</piece>

What we now have is an array <code>keyword</code> which has an entry for each keyword found,
which is "off" for a keyword not associated with this project, and "on" for an associated one.
All we have to do now is to sort the list of array keys and spit out our list.

<piece>
set tags(keywordlist) ""
foreach word [lsort [array names keyword]] {
   append tags(keywordlist) "[[input type=checkbox name=\"keyword\" value=\"$word\""
   if {$keyword($word) == "on"} { append tags(keywordlist) " checked" }
   append tags(keywordlist) ">"
   if {[lsearch $mgtwords $word] > -1} {
      append tags(keywordlist) "[[a href=\"keywords?keyword=$word\">$word[[/a>"
   } else {
      append tags(keywordlist) $word
   }
   append tags(keywordlist) "[[br>\n"
}
</piece>

</item>

<item name="todomgr_show.processlist" label="Listing processes">
So how do we do process lists?  Pretty easy.  (Well, it was pretty easy until I started
tossing all this permission stuff into it.)
<p>
If "all" is selected, then I display all processes which I own or to which I have viewing
privileges.  If "mine" is selected (i.e. "all" isn't selected) then I display all processes
which I own or to which I have 'p' privileges.
<p>
The drawback to this union is of course that I end up returning duplicate rows for processes
which are owned by the current owner.  So I use the <code>lastid</code> variable to keep track
of the last process I displayed, and if it comes up again I don't show it.  Ugh.  If anybody
can think of a more elegant solution, I'm quite open to suggestions.

<piece>
set tags(header) "[[tr bgcolor=cccccc>[[td>Process[[/td>"
if ![string compare $process all] {
   set tags(title) "All processes"
   append tags(header) "[[td>Owner[[/td>"
   set    query "select id, title, owner, status, text 'prmt' as flags from process "
   append query   "where owner='[sql_safe_string $user]' "
   append query "union "
   append query "select id, title, owner, status, flags from process, keyword, permission "
   append query   "where process.id=keyword.process and keyword.keyword=permission.keyword "
   append query     "and permission.userid='[sql_safe_string $user]' "
   append query "order by title"
} else {
   set tags(title) "My processes"
   set    query "select id, title, owner, status, text 'prmt' as flags from process "
   append query   "where owner='[sql_safe_string $user]' "
   append query "union "
   append query "select id, title, owner, status, flags from process, keyword, permission "
   append query   "where process.id=keyword.process and keyword.keyword=permission.keyword "
   append query     "and permission.userid='[sql_safe_string $user]'"
   append query     "and flags like '%p%' "
   append query "order by title"
}
append tags(header) "[[td>Status[[/td>[[/tr>"

set tags(table) ""
set rows 0
set row [ns_db select $db $query]
set lastid ""
while {[ns_db getrow $db $row]} {
   if ![string compare $lastid [ns_set get $row id]] { continue }
   set lastid [ns_set get $row id]

   append tags(table) "[[tr bgcolor=\""
   if [expr $rows % 2] {
      append tags(table) eeeeee
   } else {
      append tags(table) ffffff
   }
   append tags(table) "\">"
   incr rows

   append tags(table) "[[td>[[a href=\"overview?process=[ns_set get $row id]&who=all\">"
   append tags(table) "[ns_set get $row title][[/a> "
   if [string match *p* [ns_set get $row flags]] {
      append tags(table) "([[a href=\"show?process=[ns_set get $row id]\">modify[[/a>)[[/td>"
   }

   if [string compare $process mine] {
      append tags(table) "[[td>[ns_set get $row owner][[/td>"
   }

   append tags(table) "[[td>[ns_set get $row status][[/td>[[/tr>\n"
}
if {$rows == 0} {
   set tags(body) "[[tr>[[td colspan=3>[[i>No processes found[[/i>[[/td>[[/tr>"
}

return [todomgr_pageout $conn processlist.html]
</piece>
</item>




<item name="todomgr_overview" label="Definition of todomgr_overview">
The overview URL is used for reporting and listing of tasks.  This is the most complicated
function in the application, because there are lots of interesting ways to sort and filter
tasks.  The two input values which control which report we'll generate are <code>filter</code>
and <code>order</code>.  The <code>filter</code> parameter sets a default order, and can take
the following values:
<table border=0>
<tr bgcolor=eeeeee><td>Filter</td><td>Default order</td><td>What it shows</td></tr>
<tr><td><code>active</code> (the default)</td><td><code>priority</code></td>
  <td>Shows all outstanding active tasks.</td></tr>
<tr><td><code>scheduled</code></td><td><code>schedule</code></td>
  <td>Shows only tasks for which scheduling information has been entered.</td></tr>
<tr><td><code>today</code></td><td><code>schedule</code></td>
  <td>Same as schedule, but includes only those tasks for which the scheduled time
      is sometime today.</td></tr>
<tr><td><code>complete</code></td><td><code>process</code></td>
  <td>Shows all completed tasks.</td></tr>
<tr><td><code>full</code></td><td><code>process</code></td>
  <td>Shows everything in the task list.</td></tr>
</table>

The order parameter which the above makes use of selects among the following orders:
<table border=0>
<tr bgcolor=eeeeee><td>Order</td><td>Database order</td><td>What it's used for</td></tr>
<tr><td><code>priority</code></td><td><code>priority desc, created</code></td>
  <td>Shows tasks in descending priority order.</td></tr>
<tr><td><code>schedule</code></td><td><code>sched_date, sched_time</code></td>
  <td>Shows tasks in order of scheduled time.</td></tr>
<tr><td><code>process</code></td><td><code>process.title, created</code></td>
  <td>Shows tasks in order of process, then creation time within the process.</td></tr>
</table>

So let's figure out all that first:
<piece>
global todomgr_pool
set db [ns_db gethandle $todomgr_pool]
<insert name="user.check"/>

set form [ns_conn form $conn]
if {$form == ""} {
   set form [ns_set create]
   set filter active
   set order priority
} else {
   set filter [ns_set get $form filter]

   set order [ns_set get $form order]
   if ![string compare $order ""] {
      switch -- $filter {
         active { set order priority }
         scheduled { set order schedule }
         complete { set order process }
         full { set order process }
         default { set order priority }
      }
   }
}
</piece>

The default filter is active -- except in the case of the process home, where I think the
default should be full (i.e. show all tasks, whether active, rejected, or complete.)  Let's 
make that behavior explicit.

<piece>
set process [ns_set get $form process]
if ![string compare $filter ""] {
   if [string compare $process ""] {
      set filter full
   } else {
      set filter active
   }
}
</piece>

OK, at this point we know at least what we're doing.  Let's go ahead and translate our filter
and order parameters into actual where and order by clauses suitable for building our query.

set process [ns_set get $form process]
<piece>
switch -- $filter {
   active    { set where "and task.status='active'" }
   scheduled { set where "and not sched_date is null" }
   complete  { set where "and task.status='complete'" }
   full      { set where "" }
   default   { set where "and task.status='active'" }
}

switch -- $order {
   priority { set orderby "order by priority desc, created" }
   schedule { set orderby "order by sched_date, sched_time, created" }
   process  { set orderby "order by title, created" }
   default  { set orderby "order by created" }
}

switch -- $filter {
   active    { set tags(title) "To do" }
   scheduled { set tags(title) "To do on date" }
   complete  { set tags(title) "Completed tasks" }
   full      { set tags(title) "All tasks" }
   default   { set tags(title) "To do" }
}
</piece>

The <code>who</code> parameter selects the user or users for which we'll be displaying
tasks.  Default is the login user.  For all tasks, use <code>who=all</code>

<piece>
set who [ns_set get $form who]
if ![string compare $who ""] { set who $user }
if [string compare $who all] {
   append where " and task.owner='[sql_safe_string $who]'"
}
</piece>

If there is a process named in the <code>process</code> then this is a process home page
we're displaying.  In this case, we restrict the task list to tasks with this process, and
we also display process information (process description and owner contact info.)

<piece>
if [string compare $process ""] {
   set prow [ns_db select $db "select * from process where id='[sql_safe_string $process]'"]
   if ![ns_db getrow $db $prow] {
      set tags(title) "Process not found"
      set tags(body) "The process <code>$process</code> couldn't be found in the database."
      return [todomgr_pageout $conn message.html]
   }
   foreach field {title description owner} { set tags($field) [ns_set get $prow $field] }

   <insert name="todomgr_show.getowner"/>

   if ![string compare $tags(owner) $user] {
      set tags(modlink) "show?process=$process"
      append tags(modlink) "&back=[ns_urlencode [ns_conn url $conn]?[ns_conn query $conn]]"
      set tags(requestlink) "create?what=task&process=$process"
      append tags(requestlink) "&back=[ns_urlencode [ns_conn url $conn]?[ns_conn query $conn]]"
   } else {
      set    query "select flags from keyword, permission "
      append query   "where keyword.process='[sql_safe_string $process]' "
      append query     "and keyword.keyword=permission.keyword "
      append query     "and permission.userid='[sql_safe_string $user]'"
      set tags(requestlink) ""
      if ![catch {set row [ns_db select $db $query]} result] {
         while {[ns_db getrow $db $row]} {
            if [string match *t* [ns_set get $row flags]] {
               set tags(requestlink) "create?what=task&process=$process"
               append tags(requestlink) "&back=[ns_urlencode [ns_conn url $conn]?[ns_conn query $conn]]"
            }
         }
      }
   }

   append where " and task.process='[sql_safe_string $process]'"
   set tags(process) $process
}
</piece>

Now let's go ahead and build our query.  Since we're working with PostgreSQL, we can't do
an outer join to get process information only when tasks are associated with processes; instead,
we are forced to build two selects and join them with a union.

<piece>
set query "
select task.*, text '' as title from task where process is null $where
union
select task.*, process.title as title from task, process where task.process=process.id $where
$orderby"
</piece>

The header is easy to build, with the caveat that I only want a Priority column if I'm looking
at priority.  Otherwise it's just clutter.

<piece>
set tags(header) "[[tr bgcolor=\"cccccc\">[[td>Task[[/td>[[td>Owner[[/td>"
set cols 3
if ![string compare $process ""] {
   append tags(header) "[[td>Process[[/td>"
   incr cols
}
if {$order == "priority"} {
   append tags(header) "[[td>Priority[[/td>"
   incr cols
}

if {$filter == "scheduled"} {
   append tags(header) "[[td>Scheduled[[/td>"
} else {
   append tags(header) "[[td>Created[[/td>"
}

if {$filter == "full"} {
   append tags(header) "[[td>Status[[/td>"
}

append tags(header) "[[/tr>\n"
</piece>

Let's build a quick back link (this can be passed to the show screens to allow us to return
to the current list after doing something with a task.)  This handoff technique is something
I've always thought was kind of a kludge, but it works in situations where you have different
URLs doing different tasks and they all have to work togther (a more structured flow of control
than your standard database-search paradigm.)
<piece>
set back "[ns_conn url $conn]"
if [string compare "" [ns_conn query $conn]] { append back "?[ns_conn query $conn]" }
set back [ns_urlencode $back]
</piece>

And now we get to the meat of the routine.  We submit the query, and organize the rows as they
come back.  The formatting of the rows is unfortunately embedded in the code instead of being
specified in the template file.  I guess I could get around that with style sheets, but I just
don't use them very often.  This would be a dandy thing to come back to later, after the
application is basically working.
<p>
The <code>rows</code> variable keeps track of whether we're in an even or odd row, so that we
can make the table stripey.  I do like those stripey tables.
<piece>
set rows 0
set tags(table) ""
if ![catch {set row [ns_db select $db $query]} result] {
   while {[ns_db getrow $db $row]} {
      append tags(table) "[[tr bgcolor=\""
      if [expr $rows % 2] {
         append tags(table) eeeeee
      } else {
         append tags(table) ffffff
      }
      append tags(table) "\">"
      append tags(table) "[[td>[[a href=\"show?task=[ns_set get $row id]&back=$back\">"
      if [string compare "" [ns_set get $row description]] {
         append tags(table) [ns_set get $row description]
      } else {
         append tags(table) [ns_set get $row id]
      }
      append tags(table) "[[/a>[[/td>"
      append tags(table) "[[td>[ns_set get $row owner][[/td>"
      if ![string compare $process ""] {
         if {[ns_set get $row process] != ""} {
            append tags(table) "[[td>"
            append tags(table) "[[a href=\"overview?process=[ns_set get $row process]&who=all&filter=active\">"
            append tags(table) "[ns_set get $row title][[/a>[[/td>"
         } else {
            append tags(table) "[[td>&nbsp;[[/td>"
         }
      }
      if {$order == "priority"} {
         set p [ns_set get $row priority]
         if {$p == ""} { set p 1 }
         append tags(table) "[[td>[[center>"
         append tags(table) "[[a href=update?task=[ns_set get $row id]"
         append tags(table) "&priority=[expr $p + 1]&back=$back>up[[/a> "
         append tags(table) "$p "
         if {$p < 2} {
            append tags(table) "dn"
         } else {
            append tags(table) "[[a href=update?task=[ns_set get $row id]"
            append tags(table) "&priority=[expr $p - 1]&back=$back>dn[[/a> "
         }
         append tags(table) "[[/center>[[/td>"
      }
      if {$filter == "scheduled"} {
         append tags(table) "[[td>[ns_set get $row sched_date] [ns_set get $row sched_time][[/td>"
      } else {
         append tags(table) "[[td>[ns_set get $row created][[/td>"
      }
      if {$filter == "full"} {
         append tags(table) "[[td>[[i>[ns_set get $row status][[/i>[[/td>"
      }
      append tags(table) "[[/tr>\n"
      incr rows
   }
}

if {$rows == 0} {
   set tags(table) "[[tr>[[td colspan=$cols>[[i>No tasks found[[/i>[[/td>[[/tr>\n"
}

if [string compare $process ""] {
   set tags(backhere) "[ns_conn url $conn]?[ns_conn query $conn]"
   set tags(processdata) [datasheet_showdata view "" $process ""]
   todomgr_pageout $conn processhome.html
} else {
   todomgr_pageout $conn overview.html
}
</piece>

</item>

<item name="todomgr_update" label="Definition of todomgr_update">
Updating of tasks and processes has the same basic shape as the other functions we've
already defined: we get the form, check whether we're working on a task or a process, then
perform the update.  Afterwards we forward the browser to the URL given by the "back"
parameter, to smooth the overall user interface.

<piece>
set form [ns_conn form $conn]
if {$form == ""} {
   set tags(title) "Nothing to update"
   set tags(body) "You need to specify something to update."
   return [todomgr_pageout $conn message.html]
}
global todomgr_pool
set db [ns_db gethandle $todomgr_pool]
<insert name="user.check"/>

set task [ns_set get $form task]
if {$task != ""} {
   <insert name=".task"/> 
   <insert name=".goback"/>
}
set process [ns_set get $form process]
if {$process != ""} {
   <insert name=".process"/>
   <insert name=".goback"/>
}

set tags(title) "Nothing to update"
set tags(body) "You need to specify either a task or a process to update."
todomgr_pageout $conn message.html
</piece>
</item>

<item name="todomgr_update.task" label="Updating task record">
Updating the task is quite simple; we grab the updatable fields (which do <i>not</i> include
the status of the task), build an update query, and run it.  The only really unpleasant aspect
is checking that the user has permission to do so, and I'll split that off into the next section.
<p>
That section returns the flag <code>$modify</code>; if the flag is set, then full modification
is allowed; if not, then only priority is modifiable by the current user.  (If the current user
has no permission at all to modify the task, then that will already have been dealt with.)

<piece>
<insert name="todomgr_update.taskcheckuser"/>
set fields [list]
foreach field {process description priority sched_date sched_time} {
   if {[ns_set find $form $field] == -1} { continue }
   if {[ns_set get $form $field] == ""} { continue }
   if {!$modify && $field != "priority"} { continue }

   if {$field == "priority"} {
      lappend fields "$field=[ns_set get $form $field]"
   } else {
      lappend fields "$field='[sql_safe_string [ns_set get $form $field]]'"
   }
}

if {[llength $fields] > 0} {
   set query "update task set "
   append query [join $fields ", "]
   append query " where id='$task'"

   ns_db dml $db $query
}
</piece>

This is coded dangerously.  I should be preprocessing the values supplied for sched_date
and sched_time in order to force them to be something usable.  At the very least I should
check for an error return on update and do something meaningful with it.  Oh, well.  This is
a prototype, right?
</item>

<item name="todomgr_update.taskcheckuser" label="Checking user permissions to update task">
The simplest case is if the user owns the task.  The task owner always has full permission.
Note the continued complete lack of error handling; one of the things I plan to do is to 
centralize query handling into one nice place, then do general error handling there.  In the
meantime, we'll just have to live with those 500 status returns.
<piece>
set query "select * from task where id='[sql_safe_string $task]'"
set row [ns_db select $db $query]
ns_db getrow $db $row
set modify 1
set priority 1
if [string compare $user [ns_set get $row owner]] {
</piece>

We assume the ability to modify and set priority.  If the current user owns the task, we won't
check further, but otherwise, if the task belongs to a process, then the process owner and 
anybody with 'm' privilege may modify the task, and anybody with 'r' privilege may change the
task's priority but may change nothing else about the task.

<piece>
   set modify 0
   set priority 0
   set process [ns_set get $row process]
   if [string compare $process ""] {
      set query "select * from process where id='[sql_safe_string $process]'"
      set row [ns_db select $db $query]
      ns_db getrow $db $row
      set modify 1
      set priority 1
      if [string compare $user [ns_set get $row owner]] {
         set modify 0
         set priority 0
         set    query "select flags from keyword, permission "
         append query   "where keyword.process='[sql_safe_string $process]' "
         append query     "and keyword.keyword=permission.keyword "
         append query     "and permission.userid='[sql_safe_string $user]'"
         set row [ns_db select $db $query]
         while {[ns_db getrow $db $row]} {
            if [string match *m* [ns_set get $row flags]] { set modify 1 }
            if [string match *r* [ns_set get $row flags]] { set priority 1 }
         }
      }
   }
}
</piece>

After all that, if the user doesn't have permission to modify anything in the task, then
we need to indicate that and return.

<piece>
if {!$modify && !$priority} {
   set tags(title) "Insufficient privilege"
   set tags(body) "You don't have sufficient privilege to update this task."
   return [todomgr_pageout $conn message.html]
}
</piece>
</item>

<item name="todomgr_update.process" label="Updating process record">
Updating the process record is, of course, even easier because we don't have that numeric
priority to special-case.

<piece>
set fields [list]
foreach field {title description} {
   if {[ns_set find $form $field] == -1} { continue }
   if {[ns_set get $form $field] == ""} { continue }

   lappend fields "$field='[sql_safe_string [ns_set get $form $field]]'"
}

if {[llength $fields] > 0} {
   set query "update process set "
   append query [join $fields ", "]
   append query " where id='$process'"

   ns_db dml $db $query
}
</piece>
</item>

<item name="todomgr_update.goback" label="Forwarding back to where the update started">
After the update is complete (whether it's a task or a process that was updated) we have
to return the user back to where the transaction started, whether that's the <code>show</code>
screen or one of the overview lists.  The starting URL is in the <code>back</code> parameter;
if not, we'll just have to present a little message saying that the update was completed and
let the user take care of the navigation for us.
<piece>
set back [ns_set get $form back]
if [string compare $back ""] {
   ns_returnredirect  $conn $back
} else {
   set tags(title) "Update complete"
   set tags(body) "Your update operation was completed."
   todomgr_pageout $conn message.html
}
return
</piece>
</item>



<item name="todomgr_complete" label="Definition of todomgr_complete">
Task completion (and rejection, in the next section) is really the only point where task list
management has anything to do with workflow, oddly enough.  (Since this is a component of
the workflow toolkit, you'd think there would be more intersection.)  
<p>
But given that this is a standalone application as well as a workflow component, we can't
simply hand task completion off to the wftk entirely.  Instead, we have to check for three
cases.  The first, and easiest, is a standalone task that isn't associated with a process
at all.  If such a task is completed, it's simply marked as complete, and we're done.
<p>
If the task belongs to a process, then we retrieve the process.  If the process has a 
definition, that's our sign that the wftk will handle completion.  If there is no definition,
then we're managing the process, and so we'll see whether the process has any additional
active tasks -- if not, we'll mark the process itself as complete.
<p>
Let's handle the overhead first:
<piece>
global todomgr_pool
global todomgr_home
set db [ns_db gethandle $todomgr_pool]
<insert name="user.check"/>
set form [ns_conn form $conn]
set task ""
if {$form != ""} { set task [ns_set get $form task] }
if {$task == ""} {
   set tags(title) "No task specified"
   set tags(body) "Task completion requires a task identifier."
   return [todomgr_pageout $conn message.html]
}
</piece>

The first thing we'll do is to retrieve the task and make sure that the current user has the
right to complete it.

<piece>
set query "select * from task where id='[sql_safe_string $task]'"
if {[catch {set row [ns_db select $db $query]} result] || ![ns_db getrow $db $row]} {
   set tags(title) "Task unknown"
   set tags(body) "The task you specified ([[code>$task[[/code>) could not be found in the database."
   return [todomgr_pageout $conn message.html]
}

if [string compare $user [ns_set get $row owner]] {
   set tags(title) "Insufficient privilege"
   set tags(body) "You are not the owner of this task.  Only the owner may complete a task."
   return [todomgr_pageout $conn message.html]
}
</piece>

So now we have that out of the way, we can get down the to business of completing the task.
If we're lucky, it's a standalone task and we can simply complete it and go on.

<piece>
set process [ns_set get $row process]
if {$process == ""} {
   set query "update task set status='complete',complete='[now]'"
   append query " where id='[sql_safe_string $task]'"
   ns_db dml $db $query
   if [string compare [ns_set get $form back] ""] {
      return [ns_returnredirect $conn [ns_set get $form back]]
   }
   set tags(title) "Task complete"
   set tags(body) "The task has been marked as complete"
   return [todomgr_pageout $conn message.html]
}
</piece>

Ah, well.  We do have a process to work on after all.  OK, let's look it up.

<piece>
set query "select * from process where id='[sql_safe_string $process]'"
set row [ns_db select $db $query]
if ![ns_db getrow $db $row] {
   set query "update task set status='complete', complete='[now]'"
   append query " where id='[sql_safe_string $task]'"
   ns_db dml $db $query
   if [string compare [ns_set get $form back] ""] {
      return [ns_returnredirect $conn [ns_set get $form back]]
   }
   set tags(title) "Task complete"
   set tags(body) "The task has been marked as complete"
   return [todomgr_pageout $conn message.html]
}
</piece>

(If the process isn't in existence for some reason, it seems to me that the easiest way to
handle the situation is to treat the task as a standalone task.)
<p>
If the process has a definition, then we need to hand things off to wftk.  After that, we'll
do whatever wftk tells us, then mark the current task as complete.
<piece>
if [string compare "" [ns_set get $row definition]] {
   set pipe [open "|${todomgr_home}wftk complete $process $task" "r"]
   set wf [split [read $pipe] \n]
   close $pipe
   wftk_interpret $db $process $wf
}
</piece>

Which leaves us with the case of a task which belongs to a process which <i>we</i> have to
check for completion.  First off, let's go ahead and mark our task complete.

<piece>
set query "update task set status='complete',complete='[now]' where id='[sql_safe_string $task]'"
ns_db dml $db $query
</piece>

OK, let's ask the database how many non-complete tasks still belong to our process, and mark the
process as complete if no more remain.  (We can't just look at active tasks, because we could
have some pending requests still outstanding.)

<piece>
set query "select count(*) as ct from task where status<>'complete' and process='[sql_safe_string $process]'"
set row [ns_db select $db $query]
ns_db getrow $db $row
if {[ns_set get $row ct] == 0} {
   set query "update process set status='complete' where id='[sql_safe_string $process]'"
   ns_db dml $db $query
}

if [string compare [ns_set get $form back] ""] {
   return [ns_returnredirect $conn [ns_set get $form back]]
}
return [ns_returnredirect $conn "overview?process=$process"]
</piece>
</item>



<item name="todomgr_reject" label="Definition of todomgr_reject">
Task rejection works almost identically to task completion.  But I'm just not sure what to do
with a rejected task.  Processes with rejected tasks won't complete, by the way, at this point.
If you have any thoughts, I'd like to hear them.

<piece>
global todomgr_pool
set db [ns_db gethandle $todomgr_pool]
<insert name="user.check"/>
set form [ns_conn form $conn]
set task ""
if {$form != ""} { set task [ns_set get $form task] }
if {$task == ""} {
   set tags(title) "No task specified"
   set tags(body) "Task rejection requires a task identifier."
   return [todomgr_pageout $conn message.html]
}
</piece>

The first thing we'll do is to retrieve the task and make sure that the current user has the
right to reject it.

<piece>
set query "select * from task where id='[sql_safe_string $task]'"
if {[catch {set row [ns_db select $db $query]} result] || ![ns_db getrow $db $row]} {
   set tags(title) "Task unknown"
   set tags(body) "The task you specified ([[code>$task[[/code>) could not be found in the database."
   return [todomgr_pageout $conn message.html]
}

if [string compare $user [ns_set get $row owner]] {
   set tags(title) "Insufficient privilege"
   set tags(body) "You are not the owner of this task.  Only the owner may reject a task."
   return [todomgr_pageout $conn message.html]
}
</piece>

So now we have that out of the way, we can get down the to business of rejecting the task.
If we're lucky, it's a standalone task and we can simply reject it and go on.

<piece>
set process [ns_set get $row process]
if {$process == ""} {
   set query "update task set status='rejected'"
   append query " where id='[sql_safe_string $task]'"
   ns_db dml $db $query
   if [string compare [ns_set get $form back] ""] {
      return [ns_returnredirect $conn [ns_set get $form back]]
   }
   set tags(title) "Task rejected"
   set tags(body) "The task has been marked as rejected"
   return [todomgr_pageout $conn message.html]
}
</piece>

Ah, well.  We do have a process to work on after all.  OK, let's look it up.

<piece>
set query "select * from process where id='[sql_safe_string $process]'"
set row [ns_db select $db $query]
if ![ns_db getrow $db $row] {
   set query "update task set status='rejected'"
   append query " where id='[sql_safe_string $task]'"
   ns_db dml $db $query
   if [string compare [ns_set get $form back] ""] {
      return [ns_returnredirect $conn [ns_set get $form back]]
   }
   set tags(title) "Task rejected"
   set tags(body) "The task has been marked as rejected"
   return [todomgr_pageout $conn message.html]
}
</piece>

(If the process isn't in existence for some reason, it seems to me that the easiest way to
handle the situation is to treat the task as a standalone task.)
<p>
If the process has a definition, then we need to hand things off to wftk.  As the core engine
hasn't been written yet, I'll punt and do <i>absolutely nothing</i>.
<piece>
if [string compare "" [ns_set get $row definition]] {
   set tags(title) "wftk must handle rejection"
   set tags(body) "This task must be rejected by the wftk engine."
   return [todomgr_pageout $conn message.html]
}
</piece>

Which leaves us with the case of a task which belongs to a process which <i>we</i> have to
check for completion.  All we do is mark the task as rejected (unlike completion, there is
nothing to do to the process.)

<piece>
set query "update task set status='rejected' where id='[sql_safe_string $task]'"
ns_db dml $db $query

if [string compare [ns_set get $form back] ""] {
   return [ns_returnredirect $conn [ns_set get $form back]]
}
set tags(title) "Task complete"
set tags(body) "The task has been marked as complete"
return [todomgr_pageout $conn message.html]
</piece>
</item>



<item name="user" label="User functionality">
The user functionality consists of two things: the most important is of course the
code to be executed before each function in order to cause the login box to pop up.
This uses <code>ns_conn authuser</code> to see if a login has already been supplied; if not,
a 401 return is used to pop the box up.
<p>
The other portion is of course a couple of screens for maintenance of the user table: a list,
a user-update function, a user-add function, user delete, and a screen to be used to request
a user ID.  (The request is anonymous and creates an inactive user record.  The record must
then be activated by an administrator.  This would be a great place to use a workflow.)
</item>

<item name="user.check" label="Checking authuser">
Checking for the authuser is pretty straightforward.  This code is executed at the beginning
of each screen.  It assumes a DB pool handle in <code>$db</code>.  If the authuser is already
set, then we check it against the database; otherwise we set the WWW-Authenticate header to
provide the details of our authentication request, and return a 401 status to invoke the
login dialog.

<p>
The userid ends up in <code>$user</code> and <code>$userrow</code> is an <code>ns_set</code>
which contains the row from the users table corresponding to that userid.  (Thus including name
and contact information.)

<piece>
set user [string tolower [ns_conn authuser $conn]]
if [string compare $user ""] {
   if [catch {set userrow [ns_db select $db "select * from users where userid='[sql_safe_string $user]'"]} result] {
      set tags(title) "Problem validating user"
      set tags(body) "The database returned an error while attempting to perform signon."
      append tags(body) "[[br>The error returned was: [[code>$result[[/code>"
      return [todomgr_pageout $conn message.html 500]
   }
   if {![ns_db getrow $db $userrow] || \
        [string compare [string tolower [ns_conn authpassword $conn]] \
                        [string tolower [ns_set get $userrow password]]]} {
      ns_set put [ns_conn outputheaders $conn WWW-Authenticate "BASIC realm=\"task list manager\""
      return [todomgr_pageout $conn auth.html 401]
   }
} else {
   ns_set put [ns_conn outputheaders $conn] WWW-Authenticate "BASIC realm=\"task list manager\""
   return [todomgr_pageout $conn auth.html 401]
}
</piece>
</item>


<item name="login_admin" label="Login management stuff">
Once I had the login functionality coded, I realized there's no good way to log <i>out</i>
short of closing your browser if you're using authuser logins.  (Please correct me if you
know of a way.)  So I wrote a quick little login management routine.  If called with no
parameters, it will report the login user (if any) and present a form to be used to select
a user to switch to, and also a form to update personal information.  If called with a username,
it forces a new login.

<piece>
ns_register_proc GET $todomgr_root/login todomgr_login

proc todomgr_login {conn ignore} {
   set userid [ns_conn authuser $conn]
   if ![string compare $userid ""] {
      return [todomgr_pageout $conn nologin.html]
   }
</piece>

At this point we know that the user is logged in and which user it is.  Let's ask the
database for information about this user.

<piece>
   global todomgr_pool
   set db [ns_db gethandle $todomgr_pool]
   set row [ns_db select $db "select * from users where userid='[sql_safe_string $userid]'"]
   ns_db getrow $db $row
   foreach field {userid password name email website} {
      set tags($field) [ns_set get $row $field]
   }
</piece>

(Apologies for the egregious lack of error handling here.  After it's all working I'll have
to go back and fix that sort of thing up.)  So we have the user's information -- let's get the
form and see what we're supposed to do.

<piece>
   set form [ns_conn form $conn]
   if {$form == ""} {
      <insert name=".showlogin"/>
   } else {
      <insert name=".modlogin"/>
   }
}
</piece>
</item>

<item name="login_admin.showlogin" label="Showing the current login">
If our login is known, then we simply display the login.html page in order to give the user
a chance to switch logins.
<piece>
set tags(title) "Current login user: $tags(userid) ($tags(name))"
return [todomgr_pageout $conn login.html]
</piece>
</item>

<item name="login_admin.modlogin" label="Switching logins">
To switch login userids, we simply check the <code>user</code> parameter and return a 401
if the authuser doesn't match.  This forces login with the given userid.
<piece>
if [string compare [string tolower $userid] [string tolower [ns_set get $form user]]] {
   ns_set put [ns_conn outputheaders $conn] WWW-Authenticate "BASIC realm=\"task list manager\""
   return [todomgr_pageout $conn auth.html 401]
}
</piece>

If they <i>do</i> match, then we'll just do the same as the showlogin.  In fact, let's just
use the exact same code.
<piece>
<insert name="login_admin.showlogin"/>
</piece>
</item>



<item name="user_admin" label="User administration screens">
The user administration screens are just like any other set of screens to maintain database
data.  They're relatively boring.  I'm putting everything into one big Tcl script just to
keep things more or less neat; let's go ahead and register the URL.

<piece>
ns_register_proc GET $todomgr_root/user todomgr_user_admin
ns_register_proc POST $todomgr_root/user todomgr_user_admin
</piece>

OK.  So what can we do with users?  We can list them, add them, modify them, and delete them.
So we have a parameter <code>action</code> which can take those values.  Default is "list".

<p>
Here's the overall handling function:
<piece>
proc todomgr_user_admin {conn ignore} {
   set form [ns_conn form $conn]
   if {$form == ""} {
      set action list
   } else {
      set action [ns_set get $form action]
   }

   global todomgr_pool
   set db [ns_db gethandle $todomgr_pool]

   switch -- $action {
      list {
         <insert name="user_admin.list"/>
         return
      }
      add {
         <insert name="user_admin.add"/>
         return
      }
      modify {
         <insert name="user_admin.modify"/>
         return
      }
      delete {
         <insert name="user_admin.delete"/>
         return
      }
   }

   set tags(title) "Unknown action"
   set tags(body) "What is this <code>$action</code> of which you speak?"
   todomgr_pageout $conn message.html
}
</piece>
</item>

<item name="user_admin.list" label="Listing users">
Listing users is easy.  The list is only available to users of level 3, however.

<piece>
<insert name="user.check"/>
if {[ns_set get $userrow permlevel] [[ 3} {
   set tags(title) "Insufficient privileges"
   set tags(body) "Your permission level is lower than 3; a level of 3 is required to view the list of users.  Sorry."
   return [todomgr_pageout $conn message.html]
}

set row [ns_db select $db "select * from users"]
set tags(body) ""
while {[ns_db getrow $db $row]} {
   append tags(body) "[[tr>[[td>"
   append tags(body) "[[input type=checkbox name=delete value=\""
   append tags(body) "[ns_urlencode [ns_set get $row userid]]\">"
   append tags(body) "[[a href=user?action=modify&user=[ns_urlencode [ns_set get $row userid]]>"
   append tags(body) "[ns_set get $row name] ([ns_set get $row userid])[[/a>[[/td>"
   append tags(body) "[[/td>[[/tr>\n"
}
if {$tags(body) == ""} {
   append tags(body) "[[i>No users found[[/i>"
}
todomgr_pageout $conn user_list.html
</piece>
</item>

<item name="user_admin.add" label="Adding users">
The "add" action is used both for a blank form display and also for actual addition of
a user.  We determine which is which by checking the query.  If <code>userid</code> is
included, then it's a new add.  First off, we'll get the fields we're interested in out of
the query.

<piece>
set fields [list]
set values [list]
set userfields {userid password name email website}

foreach field $userfields {
   set value [ns_set get $form $field]
   set tags($field) $value
   if {$value == ""} { continue }
   lappend fields $field
   if {$field != "permlevel"} {
      lappend values "'[sql_safe_string $value]'"
   } else {
      lappend values "$value"
   }
}
</piece>

At this point, <code>fields</code> is a list of fields passed into the query, and
<code>values</code> is a list of the values which correspond to those fields.  If no fields
were supplied, then we just toss the blank form up.

<piece>
if {[llength $fields] == 0} {
   return [todomgr_pageout $conn user_add.html]
}
</piece>

But even if fields were given, there may be some problem.  For instance, there may be no
userid -- without a userid we can't add a record at all.  So we'll complain and give the
requester another chance.  I like to check all possible problems up front and then give the
user a list of problems rather than simply report one at a time and then wait for the user
to figure things out after five tries.  So I have a <code>problems</code> list.  As I run
checks, I add problems to the list -- if the list is empty afterwards, then I have a clean
bill of health, otherwise I can return a bullet list of things missing.  Just a nice little
design pattern I like to use.

<piece>
set problems [list]
if ![string compare $tags(userid) ""] {
   lappend problems "You must supply a desired userid to request a userid..."
}
if ![string compare $tags(password) ""] {
   lappend problems "You must supply a password."
}

if {[llength $problems] == 0} { # got this far...
   set row [ns_db select $db "select count(*) as ct from users where userid='[sql_safe_string $tags(userid)]'"]
   ns_db getrow $db $row
   if {[ns_set get $row ct] > 0} {
      lappend problems "Sorry, the userid [[code>$tags(userid)[[/code> is taken.  Please choose something else."
   }
}

if {[llength $problems] > 0} {
   if {[llength $problems] == 1} {
      set tags(message) [lindex $problems 0]
   } else {
      set tags(message) "[[ul>"
      foreach problem $problems {
         append tags(message) "[[li> $problem\n"
      }
      append tags(message) "[[/ul>"
   }
   return [todomgr_pageout $conn user_add.html]
}

</piece>

OK, so we've gotten this far with no problems.  So let's just build the query and add the
user to the database.  All new adds come in as level-0 (inactive) users, and an admin must
bump up the level to whatever is appropriate; this allows anonymous users to request access
to the system.  I guess it open you to a kind of denial-of-service attack whereby an anonymous
malicious user adds requests until your database crashes, but in that case you should probably
put some sort of access restriction onto the whole site anyway.

<piece>
lappend fields permlevel
lappend values 0

set query "insert into users ("
append query [join $fields ", "]
append query ") values ("
append query [join $values ", "]
append query ")"
ns_db dml $db $query
return [ns_returnredirect $conn user?action=list]
</piece>
</item>

<item name="user_admin.modify" label="Modifying users">
Modification is even easier.  What we do depends on whether we have fields or not; if we
have no fields to be changed, then we'll just display a form with the current values.
After a successful change, we redirect back to the list.
<p>
A user may modify his or her own personal data, but <i>not</i> his or her permission level,
of course.  I'm not going to mess around with that in the display part; any attempt to modify
permission level (unless the user is level 3) will simply softly and silently vanish away.
<p>
If the userid is not specified, the assumption is made that the user wants to modify his or
her own information (i.e. <code>$userid</code> gets set to <code>$user</code>).
<piece>
<insert name="user.check"/>
set permlevel [ns_set get $userrow permlevel]

set fields [list]
set userid [ns_set get $form user]
if {$userid == ""} { set userid $user }
if {$permlevel [[ 3 && [string compare $userid $user]} {
   set tags(title) "Insufficient privilege"
   set tags(body)" Sorry, you don't have sufficient privilege to modify this user record."
   return [todomgr_pageout $conn message.html]
}

set tags(userid) $userid
if ![string compare $userid ""] {
   return [ns_returnredirect $conn user?action=list]
}

foreach field {password name email permlevel website} {
   set value [ns_set get $form $field]
   if {$value == ""} { continue }
   if {$field != "permlevel"} {
      lappend fields "$field='[sql_safe_string $value]'"
   } else {
      if {$permlevel [[ 3} { continue } 
      lappend fields "$field=$value"
   }
}

if {[llength $fields] > 0} {
   set query "update users set "
   append query [join $fields ", "]
   append query " where userid='[sql_safe_string $userid]'"
   ns_db dml $db $query
   if [string compare $userid $user] {
      return [ns_returnredirect $conn user?action=list]
   } else {
      return [ns_returnredirect $conn user?action=modify]
   }
}

set row [ns_db select $db "select * from users where userid='[sql_safe_string $userid]'"]
if {[ns_db getrow $db $row]} {
   foreach field {password name email userid permlevel website} {
      set tags($field) [ns_set get $row $field]
   }
   return [todomgr_pageout $conn user_mod.html]
}
set tags(title) "Unknown user $userid"
todomgr_pageout $conn user_list.html
</piece>
</item>

<item name="user_admin.delete" label="Deleting users">
Finally, deletion completes the four basic table operations.  Deletion is interesting in
that it can take multiple users at once.  After deletion we pop right back to the list.
<p>
What <code>action=delete</code> gets in its form is simply a list of "delete" keywords with
values equal to the various users to be deleted.  We can iterate over an <code>ns_set</code>
in order to get all the like-named controls.

<piece>
<insert name="user.check"/>
if {[ns_set get $userrow permlevel] [[ 3} {
   set tags(title) "Insufficient privileges"
   set tags(body) "Your permission level is lower than 3; a level of 3 is required to delete users.  Sorry."
   return [todomgr_pageout $conn message.html]
}

set size [ns_set size $form]
set deletes [list]
for {set i 0} {$i [[ $size} {incr i} {
   if {[string tolower [ns_set key $form $i]] == "delete"} {
      lappend deletes "'[sql_safe_string [ns_set value $form $i]]'"
   }
}
</piece>

Now we have the list of users to be deleted.  If any were actually listed, let's do it.

<piece>
if {[llength $deletes] > 0} {
   set query "delete from users where userid="
   append query [join $deletes " or userid="]
   ns_db dml $db $query
}
</piece>

And now back to the list.
<piece>
return [ns_returnredirect $conn user?action=list]
</piece>
</item>


<item name="keywords" label="Keyword/permission management">
The keyword functionality consists of four things: the ability to assign keywords to projects,
the ability to set user's permissions to keywords, the ability to create and manage keywords,
and the ability to list keywords.

<piece>
ns_register_proc GET $todomgr_root/keywords todomgr_keywords
ns_register_proc POST $todomgr_root/keywords todomgr_keywords

proc todomgr_keywords {conn ignore} {
   set form [ns_conn form $conn]
   if {$form == ""} { set form [ns_set create] }

   global todomgr_pool
   set db [ns_db gethandle $todomgr_pool]
   <insert name="user.check"/>

   set process [ns_set get $form process]
   if [string compare "" $process] {
      <insert name=".process"/>
      return
   }

   set userid [ns_set get $form user]
   set keyword [ns_set get $form keyword]
   if [string compare "" $userid] {
      <insert name=".user"/>
      return
   }

   if [string compare "" $keyword] {
      <insert name=".keyword"/>
      return
   }

   <insert name=".keywordlist"/>
}
</piece>
</item>

<item name="keywords.process" label="Setting/creating keywords for a process.">
This function has no display; it simply rearranges the keyword list for a process, then
returns to the process modification screen.  If the current user is the owner of the
process, then the new list simply replaces the old list.  If the current user isn't the
owner, then the new list replaces that part of the old list to which the user has 'p'
permission.
<p>
First, let's get our status with regard to the process, then we'll worry about what we're
doing with the keywords.  If the current user is the owner, then things are very simple.
<piece>
if {[catch {set prow [ns_db select $db "select * from process where id='[sql_safe_string $process]'"]} result] || \
   ![ns_db getrow $db $prow]} {
   set tags(title) "Unknown process"
   set tags(body) "The process you specified ([[code>$process[[/code>) cannot be found in the database."
   return [todomgr_pageout $conn message.html]
}

if [string compare $user [ns_set get $prow owner]] {
   if {[catch {set perm [ns_db select $db "select * from permission where process='[sql_safe_string $process]' and userid='[sql_safe_string $user]'"]} result] \
       || ![ns_db getrow $db $perm] || ![string match *p* [ns_set get $perm flags]]} {
      set tags(title) "Insufficient privilege"
      set tags(body) "You have not been granted the right to assign keywords to the project you specified."
      return [todomgr_pageout $conn message.html]
   }
}
</piece>

OK, if we've gotten this far, we know that the process exists and that we have either
ownership or sufficient privilege to deal with it.  Let's see if there is a keyword we need
to create.  If so, create it and then create a permission entry for it as well.

<piece>
set keywords [list]
if [string compare "" [ns_set get $form newkeyword]] {
   set row [ns_db select $db "select count(*) as ct from keyword where keyword='[sql_safe_string [ns_set get $form newkeyword]]'"]
   ns_db getrow $db $row
   if {[ns_set get $row ct] == 0} {
      lappend keywords [ns_set get $form newkeyword]
      ns_db dml $db "insert into permission (keyword, userid, flags) values ('[sql_safe_string [ns_set get $form newkeyword]]', '[sql_safe_string $user]', 'pmrt')"
   }
}
</piece>

Now let's read in the list of keywords to be dealt with.

<piece>
set size [ns_set size $form]
for {set i 0} {$i [[ $size} {incr i} {
   if ![string compare "keyword" [string tolower [ns_set key $form $i]]] {
      lappend keywords [ns_set value $form $i]
   }
}
</piece>

And now let's do the deed.  First we delete all the pre-existing keywords attached to this
project (that we can see).  Note: this is slipshod database programming because this is a
prototype.  It could easily lead to disaster (i.e. no keywords remaining) should a problem
turn up between delete and re-insertion.
<p>
Deletion is simple for the owner case.  It's not so simple for the non-owner case -- in fact,
I can't figure out a way to do it in SQL straight, so instead I'm loading the list of keywords
I can see and building a big old WHERE clause.  Ugly but it works.

<piece>
if ![string compare $user [ns_set get $prow owner]] {
   set query "delete from keyword where process='[sql_safe_string $process]'"
   catch {ns_db dml $db $query} result
} else {
   set deletes [list]
   set query "select keyword.keyword as k from keyword, permission where keyword.keyword=permission.keyword and keyword.process='[sql_safe_string $process]' and permission.userid='[sql_safe_string $user]'"
   if ![catch {set row [ns_db select $db $query]} result] {
      while {[ns_db getrow $db $row]} {
         lappend deletes "'[sql_safe_string [ns_set get $row k]]'"
      }
   }
   if {[llength $deletes] > 0} {
      set query "delete from keyword where process='[sql_safe_string $process]' and (keyword="
      append query [join $deletes " or keyword="]
      append query ")"
      ns_db dml $db $query
   }
}
</piece>

Now finally let's insert all our keywords.
<piece>
foreach word $keywords {
   ns_db dml $db "insert into keyword (keyword, process) values ('[sql_safe_string $word]', '[sql_safe_string $process]')"
}
</piece>

And forward back to the process modification screen.

<piece>
ns_returnredirect $conn show?process=$process
</piece>
</item>

<item name="keywords.user" label="Setting permissions for a user">
Setting permissions for a user is done by inserting a record into the permission table.
If any record at all is there, the user has viewing privileges for the keyword; flags are set
to grant further privileges.  When we come into this code, <code>$userid</code> contains the
user we're granting privileges to; <code>$user</code> contains the current user.
<p>
What we want to do is: (1) check the current user's privilege level to make sure we're allowed
to do this, (2) delete the named user's current permission record, if any, and (3) insert a
new record with the given privilege.
<p>
Let's check our privilege first.
<piece>
set query "select * from permission where keyword='[sql_safe_string $keyword]' and userid='[sql_safe_string $user]'"
if {[catch {set row [ns_db select $db $query]} result] \
    || ![ns_db getrow $db $row] \
    || ![string match *p* [ns_set get $row flags]]} {
   set tags(title) "Insufficient privilege"
   set tags(body) "Sorry, you don't have sufficient privilege to grant permissions to this keyword."
   return [todomgr_pageout $conn message.html]
}
</piece>

So let's do what we need to do: delete the appropriate permission record and add the new one.
First let's figure out what the flags should be on the new record.

<piece>
set flags ""
foreach field {p r m t} {
   if [string compare "" [ns_set get $form $field]] { append flags $field }
}
</piece>

OK, let's do the database thing.

<piece>
set query "delete from permission where keyword='[sql_safe_string $keyword]' and userid='[sql_safe_string $userid]'"
ns_db dml $db $query

set query "insert into permission (keyword, userid, flags) values ('[sql_safe_string $keyword]', '[sql_safe_string $userid]', '$flags')"
ns_db dml $db $query
</piece>

Again note the egregious lack of error handling.  I'll come back to this point later.
Well, we're done.  Let's redirect back to the keyword screen and we're outta here.

<piece>
ns_returnredirect $conn keywords?keyword=$keyword
</piece>
</item>

<item name="keywords.keyword" label="Inspecting a keyword">
Keyword inspection is the management center for a keyword.  It lists processes assigned to
the keyword, lists users with permission to the keyword, and gives administrators the ability
to set permissions and add users.  First off, let's make sure the keyword exists and that the
current user has the right to work with it.

<piece>
set query "select * from permission where userid='[sql_safe_string $user]' and keyword='[sql_safe_string $keyword]' and flags like '%p%'"
if {[catch {set row [ns_db select $db $query]} result] || ![ns_db getrow $db $row]} {
   set tags(title) "Keyword not found"
   set tags(body) "The keyword you entered ([[code>$keyword[[/code>) couldn't be found or you don't have administrative privileges to it."
   return [todomgr_pageout $conn message.html]
}

set tags(keyword) $keyword
</piece>

Next step is to build the list of processes associated with the keyword.  Since we know we have
'p' access to the keyword, there's no need to worry about filtering this list.

<piece>
set query "select * from keyword, process where keyword.process=process.id and keyword='[sql_safe_string $keyword]'"
set tags(processlist) ""
if [catch {set row [ns_db select $db $query]} result] {
   set tags(processlist) "[[i>No processes attached[[/i>"
} else {
   while {[ns_db getrow $db $row]} {
      append tags(processlist) "[[a href=show?process=[ns_set get $row id]>"
      append tags(processlist) "[ns_set get $row title][[/a>[[br>\n"
   }
   if {$tags(processlist) == ""} {
      set tags(processlist) "[[i>No processes attached[[/i>"
   }
}
</piece>

Next up is the list of users associated with the keyword.  Each line of this list is a form
which allows the update of permissions for that user.  Cool, eh?

<piece>
set tags(userlist) ""
set userlist [list]
set query "select * from users, permission where permission.userid=users.userid and keyword='[sql_safe_string $keyword]' order by name"
if [catch {set row [ns_db select $db $query]} result] {
   set tags(userlist) "[[i>No users attached[[/i>"
} else {
   while {[ns_db getrow $db $row]} {
      lappend userlist [ns_set get $row userid]
      foreach perm {p r m t} {
         set check$perm ""
         if [string match "*$perm*" [ns_set get $row flags]] {
            set check$perm " checked"
         }
      }
      append tags(userlist) "[[form action=keywords method=post>"
      append tags(userlist) "[[input type=hidden name=user value=\"[ns_set get $row userid]\">"
      append tags(userlist) "[[input type=hidden name=keyword value=\"$keyword\">"
      append tags(userlist) "[ns_set get $row name] ([ns_set get $row userid])<br>"
      append tags(userlist) "[[input name=p type=checkbox value=p$checkp>Admin"
      append tags(userlist) "[[input name=r type=checkbox value=r$checkr>Priority"
      append tags(userlist) "[[input name=m type=checkbox value=m$checkm>Modify"
      append tags(userlist) "[[input name=t type=checkbox value=t$checkt>Task"
      append tags(userlist) "[[input type=submit value=\"Update\">"
      append tags(userlist) "[[/form>"
   }
   if {$tags(userlist) == ""} {
      set tags(userlist) "[[i>No users assigned[[/i>"
   }
}
</piece>

And finally, a list of users <i>not</i> associated with the keyword, so that it's easy to 
add users.  The form for addign permissions in this case is already taken care of in the 
page template, so we don't have to worry about generating it here.

<piece>
set tags(newuserlist) ""
set query "select * from users where permlevel > 0 order by name"
if ![catch {set row [ns_db select $db $query]} result] {
   while {[ns_db getrow $db $row]} {
      if {[lsearch $userlist [ns_set get $row userid]] > -1} { continue }
      append tags(newuserlist) "[[option value=\"[ns_set get $row userid]\">"
      append tags(newuserlist) "[ns_set get $row name] ([ns_set get $row userid])\n"
   }
}
</piece>

OK, so after all that, let's present the template.  We're done.

<piece>
todomgr_pageout $conn keyword.html
</piece>
</item>

<item name="keywords.keywordlist" label="Listing keywords">
This is pretty easy.  All we need is a list of keywords to which the current user has
'p' access, and a link from each to the keyword inspection screen.  Simple enough we can
even use the message.html page template to present it.

<piece>
set query "select * from permission where userid='[sql_safe_string $user]' and flags like '%p%'"
set tags(title) "Keyword list"
set tags(body) ""
if ![catch {set row [ns_db select $db $query]} result] {
    while {[ns_db getrow $db $row]} {
      append tags(body) "[[li>[[a href=keywords?keyword=[ns_set get $row keyword]>"
      append tags(body) "[ns_set get $row keyword][[/a>\n"
   }
}
if [string compare $tags(body) ""] {
   set tags(body) "Click on a keyword to go to its management screen:[[ul>$tags(body)[[/ul>"
} else {
   set tags(body) "You appear to have admin access to no keywords."
}
todomgr_pageout $conn message.html
</piece>
</item>



<item name="pageout" label="How I'm writing pages out">
The <code>todomgr_pageout</code> function is pretty much the same as all the template
output functions I use in my daily work.  It looks for tags of the form <code>[##tag##]</code>
in a base HTML file, and replaces them with hash lookups in a <code>tags</code> variable
in its caller (in Perl I do the same by passing a hash reference in, but in Tcl I can just
look up into the stack frame of my caller, which is so incredibly arcane it gives me a little
<i>frisson</i> every time I do it.)
<p>
I've been using this ungainly hack for a long time, in several different languages now.  And
by golly I'm never going to stop!
<p>
Note that the HTTP return status is passed in as an optional parameter.  The default is, of
course, 200, but a useful alternative is 401 for user authentication, for instance.

<piece>
proc todomgr_pageout {conn file {status 200}} {
   upvar tags tags
   global todomgr_home
   set fn $todomgr_home/$file
   if {![file exists $fn]} {
      <insert name=".handle404"/>
   }

   set fil [open $fn]
   while {[gets $fil line] >= 0} {
      set hit [regexp -nocase {\[##([-a-z_ 0-9!/?]*)##\]} $line match tag]
      while {$hit} {
         regsub -all -nocase \\\[##$tag##\\\] $line [escape_ampersand [todomgr_pageout_tag_value $tag]] line
         set hit [regexp -nocase {\[##([-a-z_ 0-9!/?]*)##\]} $line match tag]
      }
      append pg $line "\n"
   }
   close $fil

   ns_return $conn $status text/html $pg
}

</piece>

If you look away from the truly horrible things we have to do to get <code>regsub</code> to
work with those square brackets, the whole thing is pretty obvious: you open the file, read in
a line at a time, and find tags of the form <code>[##tag##]</code>.  Then you pass the text
from the tag into <code>todomgr_pageout_tag_value</code>, which returns the value.  There's one
little irritating bit about that, though.  Since <code>regexp</code> has one oh-so-helpful
"feature" that I would remove given the chance: it replaces all occurences of '&' with the
match string.  So the result of <code>todomgr_pageout_tag_value</code> has to
be processed in order to escape ampersands.  But since
both <code>regsub</code> and Tcl itself have to be escaped, we end up with a triple-escape.
It's just so lovely.  Here's <code>escape_ampersand</code>:

<piece>
proc escape_ampersand {str} {
   regsub -all "&" $str \\\\\\& retval
   return $retval
}
</piece>

And of course actual retrieval of values from the <code>tags</code> array is simple.  A tag
is just an arbitrary string, so this is a dandy place to define "special" tags or even
functional tags.  I'm defining two special tags here; <code>flagopen</code> and
<code>flagclose</code>.  These are functional tags, so that <code>[##flagopen flag##]</code>
resolves to <code>&lt;!--</code> if <code>flag</code> is equal to an empty string or zero, and
resolves to an empty string otherwise.  The corresponding <code>[##flagclose flag##]</code>
resolves to <code>--&gt;</code>, of course.  This means that we can display parts of a page
conditionally depending on whether a particular flag is true or not; it allows much greater
flexibility in page design.  (And allows us to push much more of the page design into the
template so that code changes aren't necessary.)
<p>
A more complex implementation of <code>todomgr_pageout</code> could simply omit that portion
of the template enclosed in the flagopen/flagclose pair, but I'm not going to go that deep
right now.

<piece>
proc todomgr_pageout_tag_value {tag} {
   upvar tags tags
   if [string match "flagopen *" $tag] {
      set tag [string range $tag 9 end]
      if [info exists tags($tag)] {
         if {$tags($tag) != 0 && $tags($tag) != ""} { return "" }
      }
      return "[[!--"
   }
   if [string match "flagclose *" $tag] {
      set tag [string range $tag 10 end]
      if [info exists tags($tag)] {
         if {$tags($tag) != 0 && $tags($tag) != ""} { return "" }
      }
      return "-->"
   }
   if [info exists tags($tag)] { return $tags($tag) }
   return ""
} 

</piece>

The only thing left to do is to define how we handle non-existent pages.
</item>

<item name="pageout.handle404" label="Handling 404 returns">
The simplest way to do this is simply to return a standard apology and be done with it.  And
since I'm in a hurry, that's what I'll do:

<piece>
   return [ns_return $conn 404 text/html "
[[h1>404[[/h1>
[[hr>
  [[blockquote>
  [[i>You step in the stream[[br>
     the water has moved on[[br>
     page not found
  [[/i>
  [[/blockquote>

  Sorry, [[code>[ns_conn url $conn][[/code> can't be found.
"]

</piece>

Sorry for the cheesy haiku but I just love that one.  If you've ever encountered a missing link
on the rest of my site, you'll see I use it there, too.  And that's all the apology you're going
to get.

</item>



<item name="datasheet_stuff" label="Datasheet interface">
For working with datasheets, I'm defining two procedures: <code>datasheet_getvalue</code>
goes to the datasheet associated with a process and retrieves a data value, and 
<code>datasheet_setvalue</code> sets the named value.  (And of course does other XML
maintenance, like create the file if necessary.)
<p>
These functions will be used in the task/process show and update functions.
<p>
There are two global settings we'll need:
<piece>
set todomgr_xmltools "/usr/local/AOLserver/vivtek/pages/xmltools"
set todomgr_datasheets "/usr/local/AOLserver/vivtek/pages/todomgr/datasheets"

<insert name=".datasheet_getvalue"/>
<insert name=".datasheet_setvalue"/>
</piece>

These functions, by the way, are based on my
<a href="http://www.vivtek.com/xmltools/">command-line XML utilities</a> to simplify the
Tcl end.  The xmltools are written on James Clark's
<a href="http://www.vivtek.com/expat.html">expat</a>, a nice, solid XML parser.

<p>
These functions are in turn called by <code>datasheet_showdata</code>, which, given a process
ID and optional task ID, iterates down the list of data to display data attached to the
named task or to the process if the task is not supplied.  The same function is used to
generate either an editing form or a simple static view.  The output is organized into
table rows of two columns; this output is assumed to be assigned to a tag, so that the
table element itself will be supplied elsewhere (usually on the format page.)
<piece>
<insert name=".datasheet_showdata"/>
</piece>

<p>
In addition to the basic functions, I'm defining one URL handler, setvalue; setvalue will
take a process and task ID and information about the value or values, and create it or replace
it using <code>datasheet_setvalue</code>.  The corresponding use of
<code>datasheet_getvalue</code> is kind of here and there throughout the show screens.
<piece>
ns_register_proc GET  $todomgr_root/setvalue setvalue
ns_register_proc POST $todomgr_root/setvalue setvalue
<insert name=".setvalue"/>
</piece>
</item>

<item name="datasheet_stuff.setvalue" label="URL handler setvalue">
This proc handles value setting operations by making calls to <code>datasheet_setvalue</code>.
Obviously this isn't the most efficient way of handling things, but it works, and it's
extremely modular, so it should be easy to maintain.  In the interests of scalability, we'll
want to investigate more integrated approaches to datasheet maintenance.

<piece>
proc setvalue {conn ignore} {
   set form [ns_conn form $conn]
   if {$form == ""} { 
      set tags(title) "No parameters given"
      set tags(body) "You can't set a value without giving the value."
      return [todomgr_pageout $conn message.html]
   }
   set process [ns_set get $form process]
   set task [ns_set get $form task]
   set newname [ns_set get $form newname]
   if [string compare "" $newname] {
      datasheet_setvalue $process $task $newname [ns_set get $form type] ""
      return [ns_returnredirect $conn [ns_set get $form back]
   }

   set size [ns_set size $form]
   for {set i 0} {$i < $size} {incr i} {
      if {-1 < [lsearch {process task back newname type} [ns_set key $form $i]]} { continue }

      datasheet_setvalue $process $task [ns_set key $form $i] "" [ns_set value $form $i]
   }
   return [ns_returnredirect $conn [ns_set get $form back]]
}
</piece>
</item>


<item name="datasheet_stuff.datasheet_getvalue" label="Definition of datasheet_getvalue">
The getvalue procedure must not only retrieve the value, but format it as an appropriate
field as well so that we can include it into a form for update.  The <code>active</code>
parameter governs whether the caller wants a form field or just a value; the return
from the proc is a list consisting of name, type, and the value or field insert.
<p/>
I have the feeling that paragraph didn't make a lot of sense, so I'll probably come back
and rewrite it later.
<p/>
At any rate, the data values attached to a task or directly to the process are accessed
not by name, but by number.  This allows a form to be built by scanning up until a blank
return.  The return value is a list consisting of the data item's: id, type, value, the
HTML needed to edit the value, and a full list of attributes attached to the element.
<p/>
Note the gyrations required to detect an empty data element (i.e. a data value with a
value of the empty string.)  Sheesh.
<piece>
proc datasheet_getvalue {process task number {active 0}} {
   global todomgr_datasheets
   global todomgr_xmltools
   set datasheet "$todomgr_datasheets/$process"
   if ![file exists $datasheet] return ""

   set loc datasheet
   if [string compare $task ""] { append loc ".task\[$task\]" }
   append loc ".data($number)"

   set data [exec $todomgr_xmltools/xmlsnip $loc $datasheet]
   if {0 == [regexp ^[[(\[^[[\]*)> $data tag bits]} { return "" }
   if  [string match */ $bits] {
      set data ""
      regsub /$ $bits "" bits
   } else {
      regsub ^[[\[^[[\]*> $data "" data
      regsub [[\[^>\]*>$ $data "" data
   }
   set fields [list]
   set id ""
   set type ""
   set bits [split [join [lrange [split $bits] 1 end]] =]
   set name [lindex $bits 0]
   foreach bit [lrange $bits 1 end] {
      set bit [split $bit \"]
      lappend fields [list $name [lindex $bit 1]]
      switch $name {
         id { set id [lindex $bit 1] }
         type { set type [lindex $bit 1] }
      }
      set name [string trim [lindex $bit 2]]
   }
   switch $type {
      string { set html "[[input name=\"$id\" value=\"$data\">" }
      text { set html "[[textarea name=\"$id\" rows=5 cols=40>$data[[/textarea>" }
      default { set html "[[input name=\"$id\" value=\"$data\">" }
   }
   return [list $id $type $data $html $fields]
}
</piece>
</item>

<item name="datasheet_stuff.datasheet_showdata" label="Definition of datasheet_showdata">
The <code>datasheet_showdata</code> is used from the task and process screens to build the
form necessary to edit attached data (or simply to view it otherwise).  If the action is
<code>edit</code>, then it needs the <code>back</code> parameter to give to the setvalue
URL handler as a redirect target.
<piece>
proc datasheet_showdata {action back process task} {
   set retval ""
   set i 0

   while (1) {
      set d [datasheet_getvalue $process $task $i]
      incr i
      if ![string compare "" [lindex $d 0]] { break }
      if {$action == "edit"} {
         append retval "[[tr>[[td>[lindex $d 0]:[[/td>[[td>[lindex $d 3][[/td>[[/tr>\n"
      } else {
         append retval "[[tr>[[td>[lindex $d 0]:[[/td>[[td>[lindex $d 2][[/td>[[/tr>\n"
      }
   }

   if {$action == "edit" && $retval != ""} {
      set retval "[[form action=setvalue method=post>\n$retval"
      append retval "[[input type=hidden name=process value=\"$process\">\n"
      append retval "[[input type=hidden name=task value=\"$task\">\n"
      append retval "[[input type=hidden name=back value=\"$back\">\n"
      append retval "[[tr>[[td colspan=2>[[center>"
      append retval "[[input type=submit value=\"Update values\">[[/center>[[/td>[[/tr>\n"
      append retval "[[/form>\n"
   }

   return $retval
}
</piece>
</item>

<item name="datasheet_stuff.datasheet_setvalue" label="Definition of datasheet_setvalue">
To set the value, we have to<ul>
<li>Make sure there's a file there
<li>If this is a task value, make sure the task has an entry in the datasheet
<li>Make sure there's a value there
<li>Finally, replace (or insert) the value.
</ul>
Not too onerous, eh?
<piece>
proc datasheet_setvalue {process task name type value} {
   if ![string compare "" $process] { return }
   regsub -all "\"" $name ' name
   global todomgr_datasheets
   global todomgr_xmltools
   set datasheet "$todomgr_datasheets/$process"
   set loc datasheet
   if [string compare $task ""] { append loc ".task\[$task\]" }

   if ![file exists $datasheet] {
      exec $todomgr_xmltools/xmlcreate datasheet > $datasheet
   }
   if [string compare $task ""] {
      set taskloc [exec $todomgr_xmltools/xmlsnip -otl datasheet.task\[$task\] $datasheet]
      if ![string compare $taskloc ""] {
         exec mv $datasheet $datasheet.~
         set pipe [open "|$todomgr_xmltools/xmlinsert aftercontent datasheet $datasheet.~ > $datasheet" w]
         puts $pipe "<task id=\"$task\">"
         puts $pipe "</task>"
         close $pipe
      }
   }
   set dataloc [exec $todomgr_xmltools/xmlsnip -otl $loc.data\[$name\] $datasheet]
   if [string compare $dataloc ""] {
      exec mv $datasheet $datasheet.~
      regsub -all " " $name "\\ " n
      set cmd "|$todomgr_xmltools/xmlreplace -m $loc.data\[$n\] $datasheet.~ > $datasheet"
      set pipe [open $cmd w]
      puts -nonewline $pipe $value
      close $pipe
   } else {
      exec mv $datasheet $datasheet.~
      set cmd "|$todomgr_xmltools/xmlinsert aftercontent $loc $datasheet.~ > $datasheet"
      set pipe [open $cmd w]
      puts $pipe "<data id=\"$name\" type=\"$type\">$value</data>"
      close $pipe
   }
}
</piece>
</item>



<item name="wftk_interpret" label="Interpreting the results that wftk sends back">
When wftk is run to start a process or to complete a task, it returns a series of lines which
encode what should happen next.  Most important of these is what tasks to activate.  The
<code>wftk_interpret</code> function takes a list of lines returned from the wftk core engine,
and does the task creation and notification specified.

<piece>
proc wftk_interpret {db process workflow} {
   while {[llength $workflow] > 0} {
      set cmd [lindex $workflow 0]
      set workflow [lrange $workflow 1 end]

      switch [string range $cmd 0 0] {
         A {
             <insert name=".task"/>
         }
         L {
             <insert name=".alert"/>
         }
         F {
             <insert name=".complete"/>
         }
      }
   }
}
</piece>
</item>

<item name="wftk_interpret.task" label="Starting tasks">
Task creation, at least, is relatively straightforward.
<piece>
set p [split [string range $cmd 2 end] -]

set fields [list id status created]
set values [list '[lindex $p 0]' 'active' '[now]']

lappend fields process
lappend values "'$process'"

lappend fields owner
set owner [lindex $p 1]
if ![string compare $owner "!user"] {
   upvar user user
   set owner $user
}
lappend values '[sql_safe_string $owner]'

lappend fields description
lappend values '[sql_safe_string [join [lrange $p 2 end] -]]'

set query "insert into task ("
append query [join $fields ", "]
append query ") values ("
append query [join $values ", "]
append query ")"

ns_db dml $db $query
</piece>
</item>

<item name="wftk_interpret.alert" label="Handling notifications">
</item>

<item name="wftk_interpret.complete" label="Completing the process">
<piece>
set query "update process set status='complete' where id='$process'"
ns_db dml $db $query
</piece>
</item>

<item name="util" label="Miscellaneous utility functions">
These are some functions I end up using a lot for AOLserver/Tcl applications.  The
<code>now</code> function is pretty obvious, and the <code>sql_safe_string</code> function
simply doubles single quotes in order to make strings safe to insert into SQL queries.

<piece>
proc now {{what all}} {
   set time [ns_localtime]
   switch $what {
    all {return [format "%04d-%02d-%02d %02d:%02d:%02d" [expr [lindex $time 5] + 1900] [expr [lindex $time 4] + 1] [lindex $time 3] [lindex $time 2] [lindex $time 1] [lindex $time 0]]}
    date {return [format "%04d-%02d-%02d" [expr [lindex $time 5] + 1900] [expr [lindex $time 4] + 1] [lindex $time 3]]}
    time {return [format "%02d:%02d:%02d" [lindex $time 2] [lindex $time 1] [lindex $time 0]]}
    tag {return [format "%04d%02d%02d%02d%02d%02d" [expr [lindex $time 5] + 1900] [expr [lindex $time 4] + 1] [lindex $time 3] [lindex $time 2] [lindex $time 1] [lindex $time 0]]}
   }
}

proc sql_safe_string {s} {
   set out ""
   while {[string first "'" $s] > -1} {
      set f [string first "'" $s]
      append out [string range $s 0 $f]
      append out "'"
      set s [string range $s [expr $f + 1] end]
   }
   append out $s

   return $out
}
</piece>

I suppose I could use <code>regsub</code> to implement <code>sql_safe_string</code> but this
works and I trust it.  (I wrote it very early on in my Tcl days.  Ah, gotta love those code
fossils.)
</item>

</litprog>
